[{"title":"Java中的引用","date":"2022-01-11T08:45:37.000Z","path":"/posts/1ae51239/","text":"拷贝引用拷贝深拷贝对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。 实现重写clone()方法类中所有自定义引用变量的类实现Cloneable接口实现clone()方法，字符类等引用类型创建一个新的字符串（引用类型）实现拷贝。以Son类为例：123456789//Son clone()方法@Overrideprotected Son clone() throws CloneNotSupportedException { // 待返回克隆的对象 Son son = (Son) super.clone(); son.name = new String(name); son.father = father.clone(); return son;} 序列法序列化会储存对象的属性但是不会也无法存储对象在内存中地址相关信息，所以在反序列化成Java对象时候会重新创建所有的引用对象。对于类有多层引用的情况，序列化后将二进制字节流内容写到一个媒介（文本或字节数组），然后从这个媒介读取数据，原对象写入这个媒介后拷贝给clone对象，原对象的修改不会影响clone对象，因为clone对象是从这个媒介读取。在具体实现上，自定义的类需要实现Serializable接口。在需要深拷贝的类(Son)中定义一个函数返回该类对象：1234567891011121314151617protected Son deepClone() throws IOException, ClassNotFoundException { Son son = null; // 在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组中 // 默认创建一个大小为32的缓冲区 ByteArrayOutputStream byOut = new ByteArrayOutputStream(); // 对象的序列化输出，通过字节数组的方式进行传输 ObjectOutputStream outputStream = new ObjectOutputStream(byOut); // 将当前student对象写入字节数组中 outputStream.writeObject(this); // 在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区 // 接收字节数组作为参数进行创建 ByteArrayInputStream byIn = new ByteArrayInputStream(byOut.toByteArray()); ObjectInputStream inputStream = new ObjectInputStream(byIn); son = (Son) inputStream.readObject(); //从字节数组中读取 return son;} 浅拷贝浅拷贝会创建一个新对象，新对象和原对象本身没有任何关系，但所有变量的值都与原来的对象相同，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所拷贝的对象，而不复制它所引用的对象。 如果属性是基本类型(int,double,long,boolean等)，拷贝的就是基本类型的值 如果属性是引用类型，拷贝的就是内存地址（即复制引用但不复制引用的对象） ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 实现在需要拷贝的类上实现Cloneable接口并重写其clone()方法，使用的时候直接调用类的clone()方法即可。123456789101112public class Demo implements Cloneable{ @Override public Demo clone() { try { Demo clone = (Demo) super.clone(); // TODO: copy mutable state here, so the clone can't change the internals of the original return clone; } catch (CloneNotSupportedException e) { throw new AssertionError(); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Father { String name; public Father(String name) { this.name = name; } @Override public String toString() { return new StringJoiner(\", \", Father.class.getSimpleName() + \"[\", \"]\") .add(\"name='\" + name + \"'\") .toString(); }}public class Son implements Cloneable { int age; String name; Father father; public Son(String name,int age) { this.age=age; this.name = name; } public Son(String name,int age, Father father) { this.age=age; this.name = name; this.father = father; } @Override public String toString() { return new StringJoiner(\", \", Son.class.getSimpleName() + \"[\", \"]\") .add(\"age=\" + age) .add(\"name='\" + name + \"'\") .toString(); } @Override protected Son clone() throws CloneNotSupportedException { return (Son) super.clone(); }}public class test { public static void main(String[] args) throws CloneNotSupportedException { Father f = new Father(\"bigFather\"); Son s1 = new Son(\"son1\", 13); // 引用 s1.father = f; // 浅拷贝，s2的地址和s1地址不同，但内容信息一致 Son s2 = s1.clone(); System.out.println(s1); System.out.println(s2); // 地址不同，所以结果不相等 System.out.println(\"s1==s2:\" + (s1 == s2)); // s1和s2内容信息一致，所以结果相等 System.out.println(\"s1.name==s2.name:\" + (s1.name == s2.name)); // 变更s1里age的指向 s1.age = 12; // s1.father.name指向变更，但s1的father引用未变 s1.father.name = \"smallFather\"; // 变更s1里name的指向 s1.name = \"son222\"; // s1、s2的father引用未变，结果相等 System.out.println(\"s1.Father==s2.Father:\" + (s1.father == s2.father)); // 不相等 System.out.println(\"s1.name==s2.name:\" + (s1.name == s2.name)); System.out.println(s1); System.out.println(s2); }} new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球） 对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 引用强引用弱引用在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 软引用虚引用参考文献 5张图搞懂Java引用拷贝、深拷贝、浅拷贝 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"https://niithub.cn/tags/Java/"},{"name":"引用","slug":"引用","permalink":"https://niithub.cn/tags/%E5%BC%95%E7%94%A8/"}]},{"title":"JVM内存","date":"2021-12-24T10:13:39.000Z","path":"/posts/f3dc315c/","text":"本文讨论的内存空间基于Jdk8 程序计数器线程私有（为了线程切换后能恢复到正确的执行位置），也称为代码的行号指示器，字节码解释器就是通过改变程序计数器的位置来确定下一行要执行的代码，是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。如果线程正在执行一个Java方法，那么它记录的是正在执行虚拟机字节码指令的地址，如果是一个native方法那么它的值为空。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 Java虚拟机栈线程私有的，它的声明周期和线程一致。每个线程创建时都会创建一个虚拟机栈，内部保存了一个个的栈帧，每个栈帧就对应着一次方法的调用。既然知道了虚拟机栈里面存放的是一个个的栈帧，那么也不难猜出虚拟机栈里面都存储了什么东西。Java虚拟机栈是存在OOM的，当线程所请求的栈的深度大于虚拟机栈的深度或者虚拟机栈可以动态扩容，当栈扩展时无法申请到足够的内存时，就会抛出OOM。 虚拟机栈内部结构 局部变量表主要存储方法的参数，所有的基本类型数据和对象地址，以及返回地址类型（return address）。它以变量槽为最小的存储单位，Java虚拟机并没有规定一个变量槽占用多少内存空间，但是规定了一个变量槽可以存放一个32位以内的数据类型。如果存储的数据类型超过32位，比如long、double，那么就使用两个变量槽进行存储。 操作数栈操作数栈是一个先进后出的操作数栈，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的，它主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。如果被调用的方法有返回值，那么返回值将会被压入当前栈帧的操作数栈中。操作数栈并非采用索引的方式进行数据访问，而是通过入栈（push）和出栈（pop）操作来完成数据的访问。 动态链接栈帧中保存了一个方法的引用，当执行方法的时候，可以拿着这个引用到运行时常量池中找到这个方法。动态链接的作用就是将这些方法的符号引用转换为调用方法的直接引用。 方法返回地址在方法执行结束之后，要返回下一条要执行代码位置的值，也就是程序计数器的值。异常导致的方法退出，不会返回任何值的。对于抛出的异常，栈帧中不会做任何记录，但是会记录在一个异常表中。 本地方法栈虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈线程私有，为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 堆Java堆是虚拟机中最大的一块内存空间，它被所有的线程共享，在虚拟机启动时创建。它唯一的目的就是存放对象实例。随着即时编译技术的发展进步，尤其是逃逸分析技术的日渐强大，栈上分配、变量替换等优化手段，让实例在”只在堆“中分配不再成为绝对。Java堆是垃圾收集的主要区域，Java堆中也经常出现新生代、老年代、永久代等等，这里需要注意，这些并不是Java堆物理上的内存布局，它是作为垃圾收集器而划分一种内存布局。 方法区线程共享的区域，主要用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。方法区它是可以被垃圾收集器进行回收的，主要针对类型的卸载和常量池的回收。方法区也可以产生OOM，当方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池表，它用来存储编译期生成的各种字面量和符号引用。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"https://niithub.cn/tags/Java/"},{"name":"Jvm","slug":"Jvm","permalink":"https://niithub.cn/tags/Jvm/"}]},{"title":"IO实践","date":"2021-12-21T08:21:51.000Z","path":"/posts/17b7d358/","text":"本文讨论的I/O均在Java框架内 基本概念I/OBIO (Blocking I/O)同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。 NIO (New I/O)NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，它支持基于通道、面向缓冲的I/O操作方法。NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。 AIO (Asynchronous I/O)AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。 同步/异步同步发起一个调用后，被调用者未处理完请求之前，调用不返回。 异步发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。 阻塞/非阻塞阻塞发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。 非阻塞发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。 BIO 在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。 传统BIO模型示例 采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成。可以通过多线程来支持多个客户端的连接，如上图所示。 多线程处理的Socket服务端代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class ListeningThread { private static final Logger LOGGER = LoggerFactory.getLogger(ListeningThread.class); public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(111); new Thread(() -&gt; { while (true) { if (serverSocket.isClosed()) { break; } try { Socket socket = serverSocket.accept(); new ConnectionThread(socket).start(); } catch (IOException e) { LOGGER.error(\"\", e); } } }); }}class ConnectionThread extends Thread { private static final Logger LOGGER = LoggerFactory.getLogger(ConnectionThread.class); // 心跳时间间隔是60s private static final int HEARTBEAT_INTERVAL = 60000; private Socket socket; private boolean isRunning; private long lastHeartbeat; public ConnectionThread(Socket socket) { this.socket = socket; isRunning = true; } @Override public void run() { // 心跳的线程 new Thread(() -&gt; { lastHeartbeat = LocalDateTime.now().toInstant(ZoneOffset.of(\"+8\")).toEpochMilli(); while (isRunning) { long curTime = new Date().getTime(); // 如果当前时间距离上次心跳的时间间隔超过设置的时间间隔（60s），则断开连接 if (curTime - lastHeartbeat &gt; HEARTBEAT_INTERVAL) { LOGGER.info(\"Socket[{}] timeout {}s.\", socket.getInetAddress(), HEARTBEAT_INTERVAL / 1000); stopRunning(); break; } try { Thread.sleep(5000); } catch (InterruptedException e) { LOGGER.error(\"\", e); Thread.currentThread().interrupt(); } } }); while (isRunning) { // Check whether the socket is closed. if (socket.isClosed()) { isRunning = false; break; } try { InputStream inputStream = socket.getInputStream(); byte[] temp = new byte[8]; int bytes = 0; bytes = inputStream.read(temp); if (bytes == -1) { inputStream.close(); return; } // 设置最近一次消息时间 lastHeartbeat = new Date().getTime(); } catch (SocketException e) { LOGGER.info(\"Socket [{}] is closed! [{}]\", socket.getInetAddress(), e.getMessage()); if (!socket.isClosed()) { stopRunning(); } } catch (IOException e) { LOGGER.error(\"\", e); if (!socket.isClosed()) { stopRunning(); } } } } public void stopRunning() { isRunning = false; try { socket.close(); } catch (IOException e) { LOGGER.error(\"\", e); } }} 基于线程池的BIO NIO 基于通道、面向缓冲的I/O操作 NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用简单，但性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。 特点： Selector 对应一个线程， 一个线程对应多个 channel(连接) 每个 channel 都注册到 Selector选择器上 每个 channel 都会对应一个 Buffer，channel 是双向的，可以读也可以写 Selector不断轮询查看Channel上的事件 Selector 会根据不同的事件，完成不同的处理操作 数据的读取写入是通过 Buffer Selector(选择器)Selector是用来监控SocketChannel的事件的，其实是实现非阻塞的关键，使用单个线程处理多个通道。 获得选择器对象 1Selector.open(); 通道设置成非阻塞 1234ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.bind(inetSocketAddress);serverSocketChannel.configureBlocking(false);serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); Selector定义了四种事件，OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT。 事件类型 释义 对应函数 SelectionKey.OP_ACCEPT 连接就绪事件，表示服务器监听到客户连接，可以接收信息 SelectionKey.isAcceptable() SelectionKey.OP_CONNECT 连接就绪事件，表示客户端与服务器成功建立连接 SelectionKey.isConnectable() SelectionKey.OP_READ 读就绪事件，表示通道中存在可读数据，可以执行读操作 SelectionKey.isReadable() SelectionKey.OP_WRITE 写就绪事件，表示已经可以向通道写数据 SelectionKey.isWritable() Channel(通道)NIO 通过Channel（通道） 进行读写。通道是双向的，可读也可写。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。 Channel的实现类： FileChannel : 用于文件的数据读写 DatagramChannel : 用于 UDP 的数据读写 ServerSocketChannel : 类似 ServerSocket，用于 TCP 的数据读写 SocketChannel : 类似 Socket，用于 TCP 的数据读写 Buffer(缓冲区) 方法名 说明 static ByteBuffer allocate(长度) 创建byte类型的指定长度的缓冲区 static ByteBuffer wrap(byte[] array) 创建一个有内容的byte类型缓冲区 int position()/position(int newPosition) 获得当前要操作的索引/修改当前要操作的索引位置 int limit()/limit(int newLimit) 获取最多能操作到哪个索引/修改最多能操作的索引位置 int capacity() 返回缓冲区的总长度 int remaining()/boolean hasRemaining() 还有多少能操作索引个数/是否还有能操作 put(byte b)/put(byte[] src) 添加一个字节/添加字节数组 flip() 写切换读模式 limit设置position位置, position设置0 get() 读一个字节 get(byte[] dst) 读多个字节 get(int index) 读指定索引的字节 rewind() 将position设置为0，可以重复读 clear() 切换写模式 position设置为0 , limit 设置为 capacity array() 将缓冲区转换成字节数组返回 服务端代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class NioSocketServer { private ByteBuffer buffer = ByteBuffer.allocate(1024); private Selector selector; public static void main(String[] args) { Runnable run = () -&gt; { NioSocketServer socketServer = new NioSocketServer(); try { socketServer.start(); } catch (IOException e) { e.printStackTrace(); } }; new Thread(run).start(); } public void start() throws IOException { this.selector = Selector.open(); ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.bind(new InetSocketAddress(111)); // 通道设置为非阻塞, 因为selector需要轮询监听每个通道的事件 serverSocketChannel.configureBlocking(false); // 指定监听事件为 OP_ACCEPT 连接就绪 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) { this.selector.select(); Set&lt;SelectionKey&gt; selectionKeySet = this.selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeySet.iterator(); SelectionKey key; while (iterator.hasNext()) { key = iterator.next(); iterator.remove(); if (!key.isValid()) { this.close(key); continue; } if (key.isAcceptable()) { this.accept(key); } if (key.isReadable()) { this.read(key); } } } } private void accept(SelectionKey selectionKey) { ServerSocketChannel serverChannel = (ServerSocketChannel) selectionKey.channel(); try { SocketChannel channel = serverChannel.accept(); channel.configureBlocking(false); Socket socket = channel.socket(); SocketAddress remoteAddr = socket.getRemoteSocketAddress(); System.out.println(\"Connected to: \" + remoteAddr); channel.register(this.selector, SelectionKey.OP_READ); } catch (IOException e) { System.out.println((\"读取socket通信信息失败，异常信息：\" + e.toString())); } } /** * 读取socket信息 * * @param selectionKey */ private void read(SelectionKey selectionKey) { buffer.flip(); int numRead = -1; try { SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); numRead = socketChannel.read(buffer); } catch (IOException e) { System.out.println(\"socket读取信息失败，失败信息：\" + e.toString()); } if (numRead == -1) { this.close(selectionKey); } byte[] data = new byte[numRead]; System.arraycopy(buffer.array(), 0, data, 0, numRead); System.out.println(\"客户端消息:\" + new String(data)); } /** * 关闭连接 * * @param selectionKey */ private void close(SelectionKey selectionKey) { if (selectionKey == null) { return; } SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); if (!socketChannel.isConnected()) { return; } Socket socket = socketChannel.socket(); SocketAddress remoteAddr = socket.getRemoteSocketAddress(); System.out.println(\"Connection closed by client: \" + remoteAddr); try { socketChannel.close(); } catch (IOException e) { System.out.println(\"socket关闭失败，失败信息：\" + e.toString()); } selectionKey.cancel(); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"https://niithub.cn/tags/Java/"},{"name":"NIO","slug":"NIO","permalink":"https://niithub.cn/tags/NIO/"},{"name":"IO","slug":"IO","permalink":"https://niithub.cn/tags/IO/"}]},{"title":"微服务设计架构","date":"2021-12-21T08:19:33.000Z","path":"/posts/2b221c31/","text":"应用架构下载地址 微服务设计模式下载地址 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"微服务","slug":"微服务","permalink":"https://niithub.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"架构","slug":"架构","permalink":"https://niithub.cn/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"Git操作命令","date":"2021-12-14T10:23:54.000Z","path":"/posts/159ed7e6/","text":"撤销本次pull121. git reflog2. git reset --hard 哈希值 撤销本次merge1git merge --abort git log高阶用法 查看每次提交的文件修改列表，和分支变化的图形信息1git log --name-status --oneline --graph git stashgit stash 可以将当前工作状态（WIP，work in progress）临时存放在 stash 列表中，待 pull / merge 操作完成后，再从 stash 中重新应用这些修改。 查看暂存的stash列表 1git stash list 恢复上一次的 WIP 状态，并从列表中移除 1git stash pop 新增的文件也一起 stash 1git stash save document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Git","slug":"Git","permalink":"https://niithub.cn/tags/Git/"},{"name":"命令","slug":"命令","permalink":"https://niithub.cn/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"MySQL的最左前缀","date":"2021-12-07T09:31:38.000Z","path":"/posts/2649bdb8/","text":"最左前缀原则概念 创建一个联合索引(col1, col2, col3), 则该联合索引支持的索引有[(col1), (col1, col2), (col1, col2, col3)] 联合索引最多支持16列 举例存在索引 (a, b, c) 查询条件 实际使用的索引 a, b, c a, b, c a, c a a, b a, b a a b, c 无 注意：where条件顺序可以随意组装，比如 a, b, c 你可以写成 a, c, b、 c, a, b 等，这些都不影响，但是出现的字段必须是上面写到的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://niithub.cn/tags/MySQL/"},{"name":"优化","slug":"优化","permalink":"https://niithub.cn/tags/%E4%BC%98%E5%8C%96/"},{"name":"索引","slug":"索引","permalink":"https://niithub.cn/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"Java代码优化","date":"2021-12-03T03:17:32.000Z","path":"/posts/a2337e7d/","text":"尽量重用对象/循环内不要不断创建对象引用由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。举例：123for (int i = 0, a = 1; i &lt; 10000; i++) { Object o = new Object();}建议改为：1234Object o = null;for (int i = 0, a = 1; i &lt; 10000; i++) { o = new Object();}这样的话，内存中只有一份Object对象引用，每次new Object的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收. 尽量减少对变量的重复计算举例123for (int i = 0; i &lt; list.size(); i++) {}建议替换为：123for (int i = 0, int length = list.size(); i &lt; length; i++) {}这样，在list.size很大的时候，就减少了很多的消耗。 尽量采用懒加载的策略，即在需要的时候才创建当复制大量数据时，使用System.arraycopy命令乘法和除法使用移位操作用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的。举例：1234for (int i = 0, a = 1; i &lt; 10000; i++) { a = i * 8; a = i / 2;}建议改为：1234for (int i = 0, a = 1; i &lt; 10000; i++) { a = i &lt;&lt; 3; a = i &gt;&gt; 1;} 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销尽量在合适的场合使用单例使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，单例主要适用于以下三个方面： 控制资源的使用，通过线程同步来控制资源的并发访问 控制实例的产生，以达到节约资源的目的 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 尽量避免随意使用静态变量当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的。123public class A { private static B b = new B();}此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止。 使用带缓冲的输入输出流进行IO操作带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率。 不要让public方法中有太多的形参public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合 参数太多势必导致方法调用的出错概率增加 公用的集合类中不使用的数据一定要及时remove掉如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"https://niithub.cn/tags/Java/"},{"name":"代码优化","slug":"代码优化","permalink":"https://niithub.cn/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"}]},{"title":"Valid注解的使用","date":"2021-11-30T09:56:42.000Z","path":"/posts/dcc76ec7/","text":"@Valid and @Validated区别@Valid是方法级别的注解，我们可以用来校验成员属性，所在包javax.validation。注意，@Valid不支持组校验，@Validated支持组校验，所在包org.springframework.validation.annotation。 @Valid支持的校验注解 注解名称 释义 @AssertTrue 值必须是true @AssertFalse 值必须是false @DecimalMax 限制必须为一个不大于指定值的数字 @DecimalMin 限制必须为一个不小于指定值的数字 @Digits(integer, fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction @Future 限制必须是一个将来的日期 @Max 限制必须为一个不大于指定值的数字 @Min 限制必须为一个不小于指定值的数字 @Null 值不能为空 @NotNull 值不能为空 @Past 验证注解的元素值（日期类型）比当前时间早 @Pattern 限制必须符合指定的正则表达式 @Size 可以被应用于String, Collection, Map, array类型，长度必须在min and max之间 使用示例基础使用@Valid的使用示例：123456789101112131415161718public class UserAccount { @NotNull @Size(min = 4, max = 15) private String password; @NotBlank private String name; @Min(value = 18, message = \"Age should not be less than 18\") private int age; @NotBlank private String phone; // standard constructors / setters / getters / toString } 12345678@RequestMapping(value = \"/saveBasicInfo\", method = RequestMethod.POST)public String saveBasicInfo(@Valid @ModelAttribute(\"useraccount\") UserAccount useraccount, BindingResult result) { if (result.hasErrors()) { return \"error\"; } return \"success\";} 分组示例123456789101112131415161718public class UserAccount { @NotNull(groups = BasicInfo.class) @Size(min = 4, max = 15, groups = BasicInfo.class) private String password; @NotBlank(groups = BasicInfo.class) private String name; @Min(value = 18, message = \"Age should not be less than 18\", groups = AdvanceInfo.class) private int age; @NotBlank(groups = AdvanceInfo.class) private String phone; // standard constructors / setters / getters / toString } 1234567@RequestMapping(value = \"/saveBasicInfoStep1\", method = RequestMethod.POST)public String saveBasicInfoStep1(@Validated({BasicInfo.class}) @ModelAttribute(\"useraccount\") UserAccount useraccount, BindingResult result) { if (result.hasErrors()) { return \"error\"; } return \"success\";} 处理参数为List的情况1234567891011121314151617@AutowiredValidator validator;@PostMapping(value = \"\")public GxProductResult productTypeUpdate(@RequestBody List&lt;DTO&gt; dtoList) { Iterator&lt;DTO&gt; iterator = dtoList.listIterator(); // 校验参数是否合法 while (iterator.hasNext()) { DTO dto = iterator.next(); BeanPropertyBindingResult errors = new BeanPropertyBindingResult(dto, dto.getId()); validator.validate(gxProductType, errors); if (errors.hasErrors()) { FieldError fieldError = errors.getFieldError(); error.put(1, fieldError.getDefaultMessage()); } }} 参考文献 SpringBoot 中使用 @Valid 注解 + Exception 全局处理器优雅处理参数验证 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"注解","slug":"注解","permalink":"https://niithub.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://niithub.cn/tags/SpringBoot/"}]},{"title":"hexo使用说明","date":"2021-10-14T14:56:32.000Z","path":"/posts/82ca5a28/","text":"安装hexo 1npm install hexo 安装发布hexo必须的git插件 1npm install --save hexo-deployer-git 修改_config.yml 1234deploy type: git repository: git@github.com:YOUR_ID/YOUR_ID.github.io.git branch: master 新建文章 1npx hexo new [layout] &lt;title&gt; 清理hexo编译结果 1npx hexo clean hexo编译 1npx hexo g hexo发布 1npx hexo d document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"https://niithub.cn/tags/Linux/"},{"name":"安装记录","slug":"安装记录","permalink":"https://niithub.cn/tags/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"}]},{"title":"Java代理的代码示例","date":"2021-10-10T13:56:11.000Z","path":"/posts/c1b60574/","text":"静态代理StaticProxy.java123456789101112131415//代理对象class StaticProxy implements Subject{ //实际目标对象 private Subject subject; public StaticProxy(Subject subject){ this.subject = subject; } public void request(){ System.out.println(\"PreProcess\"); subject.request(); System.out.println(\"PostProcess\"); }} StaticProxyDemo.java12345678910111213//静态代理模式public class StaticProxyDemo { public static void main(String args[]){ //创建实际对象 SubjectImpl subject = new SubjectImpl(); //把实际对象封装到代理对象中 StaticProxy p = new StaticProxy(subject); p.request(); }} Subject.java12345public interface Subject{ public void request();} SubjectImpl.java12345678//目标对象class SubjectImpl implements Subject{ public void request(){ System.out.println(\"I am dealing the request.\"); }} 动态代理├─code│ ├─multiple│ │ ├─Cook.java│ │ ├─CookImpl.java│ │ ├─Driver.java│ │ ├─MultipleInterfacesProxyTest.java│ │ ├─ProxyHandler.java│ ││ │─DynamicProxyDemo.java│ │─ProxyHandler.java│ │─Subject.java│ │─SubjectImpl.java DynamicProxyDemo.java12345678910111213141516171819202122232425262728import java.lang.reflect.Proxy;//动态代理模式public class DynamicProxyDemo { public static void main(String[] args) { //1.创建目标对象 SubjectImpl realSubject = new SubjectImpl(); //2.创建调用处理器对象 ProxyHandler handler = new ProxyHandler(realSubject); //3.动态生成代理对象 Subject proxySubject = (Subject)Proxy.newProxyInstance (SubjectImpl.class.getClassLoader(), SubjectImpl.class.getInterfaces(), handler); //proxySubject真实类型com.sun.proxy.$Proxy0 //proxySubject继承Proxy类，实现Subject接口 //newProxyInstance的第二个参数，就是指定代理对象的接口 //4.客户端通过代理对象调用方法 //本次调用将自动被代理处理器的invoke方法接收 proxySubject.request(); System.out.println(proxySubject.getClass().getName()); System.out.println(proxySubject.getClass().getSuperclass().getName()); }} ProxyHandler.java123456789101112131415161718192021222324import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * 代理类的调用处理器 */class ProxyHandler implements InvocationHandler{ private Subject subject; public ProxyHandler(Subject subject){ this.subject = subject; } //此函数在代理对象调用任何一个方法时都会被调用。 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(proxy.getClass().getName()); //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作 System.out.println(\"====before====\"); Object result = method.invoke(subject, args); System.out.println(\"====after====\"); return result; }} Subject.java123public interface Subject{ public void request();} SubjectImpl.java123456//目标对象class SubjectImpl implements Subject{ public void request(){ System.out.println(\"I am dealing the request.\"); }} multiple/Cook.java12345package multiple.interfaces;public interface Cook { public void doWork();} multiple/CookImpl.java12345678package multiple.interfaces;public class CookImpl implements Cook{ public void doWork() { System.out.println(\"cook for you\"); }} multiple/Driver.java12345package multiple.interfaces;public interface Driver { public void doWork();} multiple/MultipleInterfacesProxyTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package multiple.interfaces;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Set;public class MultipleInterfacesProxyTest { public static void main(String[] args) throws Exception { Cook cook = new CookImpl(); ClassLoader cl = MultipleInterfacesProxyTest.class.getClassLoader(); ProxyHandler handler = new ProxyHandler(cook); //生成代理类型 Class&lt;?&gt; proxyClass = Proxy.getProxyClass(cl, new Class&lt;?&gt;[]{Driver.class,Cook.class}); //生成代理对象 Object proxy = proxyClass.getConstructor(new Class[]{InvocationHandler.class}). newInstance(new Object[]{handler}); System.out.println(Proxy.isProxyClass(proxyClass)); Proxy p = (Proxy) proxy; System.out.println(p.getInvocationHandler(proxy).getClass().getName()); System.out.println(\"proxy类型:\" + proxyClass.getName()); //代理对象都继承于java.lang.reflect.Proxy，但是获取父类确是Object而不是Proxy Class father = proxyClass.getSuperclass(); System.out.println(\"proxy的父类类型:\" + father.getName()); Class[] cs = proxy.getClass().getInterfaces(); for(Class c:cs) { System.out.println(\"proxy的父接口类型:\" + c.getName()); } System.out.println(\"=====================\"); Method[] ms = proxy.getClass().getMethods(); for(Method m:ms) { System.out.println(\"调用方法 \" + m.getName() + \"；参数为 \" + Arrays.deepToString(m.getParameters())); } System.out.println(\"=====================\"); Cook c = (Cook) proxy; c.doWork(); Driver d = (Driver) proxy; d.doWork(); }} multiple/ProxyHandler.java123456789101112131415161718192021222324package multiple.interfaces;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Arrays;/** * 代理类的调用处理器 */class ProxyHandler implements InvocationHandler{ private Cook cook; public ProxyHandler(Cook cook){ this.cook = cook; } //此函数在代理对象调用任何一个方法时都会被调用。 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"proxy类型:\" + proxy.getClass().getName()); System.out.println(\"调用方法 \" + method + \"；参数为 \" + Arrays.deepToString(args)); Object result = method.invoke(cook, args); return result; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"代码示例","slug":"代码示例","permalink":"https://niithub.cn/tags/%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"},{"name":"Java代理","slug":"Java代理","permalink":"https://niithub.cn/tags/Java%E4%BB%A3%E7%90%86/"}]},{"title":"PreAuthorize and PostAuthorize in Spring Security","date":"2021-06-16T06:59:28.000Z","path":"/posts/9304ed3c/","text":"Spring Security provides method level security using @PreAuthorize and @PostAuthorize annotations. This is expression-based access control.The @PreAuthorize can check for authorization before entering into method. The @PreAuthorize authorizes on the basis of role or the argument which is passed to the method.The @PostAuthorize checks for authrorisation after method execution. The @PostAuthorize authorizes on the basis of logged in roles, return object by method and passed argument to the method. For the returned object spring security provides built-in keyword i.e. returnObject. Using PreAuthorize and PostAuthorizeFind the code for @PreAuthorize and @PostAuthorize in the interface of the service layer. IBookService.java123456789101112131415161718package com.concretepage.service;import com.concretepage.bean.Book;import org.springframework.security.access.prepost.PostAuthorize;import org.springframework.security.access.prepost.PreAuthorize;public interface IBookService { @PreAuthorize(\"hasRole('ROLE_WRITE')\") public void addBook(Book book); @PostAuthorize(\"returnObject.owner == authentication.name\") public Book getBook(); @PreAuthorize(\"#book.owner == authentication.name\") public void deleteBook(Book book);} Look at the interface above, we have used @PreAuthorize and @PostAuthorize annotations. The authentication and principal keyword can directly be used to access user informations. The _#_ is used to access argument of the method.Now take attention on @PostAuthorize that built-in keyword returnObject has been used. Here returnObject is equivalent to Book instance returned by the method. Now find the Spring Security XML file.security-config.xml1&lt;http auto-config=\"true\" use-expressions=\"true\"&gt; &lt;intercept-url pattern=\"/login\" access=\"hasAnyRole('ROLE_READ','ROLE_WRITE')\" /&gt; &lt;logout logout-success-url=\"/login\" /&gt; &lt;/http&gt; &lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name=\"ram\" password=\"con1234\" authorities=\"ROLE_READ,ROLE_WRITE\" /&gt; &lt;user name=\"rahim\" password=\"con1234\" authorities=\"ROLE_READ\" /&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; &lt;global-method-security pre-post-annotations=\"enabled\"/&gt; &lt;beans:bean name=\"bookService\" class=\"com.concretepage.service.BookService\"/&gt; Enable pre-post AnnotationsTo use @PreAuthorize and @PostAuthorize annotations in our Spring Security application, we need to enable pre-post annotations. In case we are using Java configuration, then that class needs to be annotated with @EnableGlobalMethodSecurity as given below.123456@Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled=true) public class SecurityConfig extends WebSecurityConfigurerAdapter { ------ } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://niithub.cn/tags/Spring-Security/"},{"name":"Annotation","slug":"Annotation","permalink":"https://niithub.cn/tags/Annotation/"}]},{"title":"MySQL常用语句","date":"2020-11-12T12:24:02.000Z","path":"/posts/adb47c67/","text":"创建索引 在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。 ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。1ALTER TABLE table ADD INDEX 索引名 (字段名); CREATE INDEX可对表增加普通索引或UNIQUE索引123CREATE INDEX index_name ON table_name (column_list)CREATE UNIQUE INDEX index_name ON table_name (column_list) 删除索引 12345DROP INDEX index_name ON talbe_nameALTER TABLE table_name DROP INDEX index_nameALTER TABLE table_name DROP PRIMARY KEY 前两条语句是等价的，删除掉table_name中的索引index_name，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。 表中插入数据 1insert into 表名 (字段名, 字段名, 字段名) values(对应值, 对应值, 对应值); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://niithub.cn/tags/MySQL/"},{"name":"语句","slug":"语句","permalink":"https://niithub.cn/tags/%E8%AF%AD%E5%8F%A5/"}]},{"title":"多次读取@Requestbody中的数据","date":"2020-11-12T11:37:35.000Z","path":"/posts/2596fc85/","text":"问题现象为了保证接口请求的安全性，一般都会做签名校验，系统在接收到请求执行相关逻辑操作前，先使用拦截器获取@RequestBody中的签名数据，做安全校验。因为业务需要，某个接口做了两次校验，即两处都需要从@RequestBody中获取数据做校验。此时，系统抛出以下异常：1I/O error while reading input message; nested exception is java.io.IOException: Stream closed 分析POST方式是以流的方式来传递数据，而流只能读取、使用一次。在拦截器中读取@Requestbody中的数据后，@Requestbody中的数据将不复存在，导致第二次读取数据时抛异常。 解决办法 读取流前先把流保存一下 使用过滤器拦截读取，再通过chain.doFilter(wrapper, response);将保存的流丢到后面程序处理 实施新建一个类读取RequestBody新建HttpHelper类的目的在于读取RequestBody 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.http.HttpServletRequest;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.charset.Charset;public class HttpHelper { private static final Logger LOGGER = LoggerFactory.getLogger(HttpHelper.class); public static String getBodyString(HttpServletRequest request) { StringBuilder sb = new StringBuilder(); InputStream inputStream = null; BufferedReader reader = null; try { inputStream = request.getInputStream(); reader = new BufferedReader(new InputStreamReader(inputStream, Charset.forName(\"UTF-8\"))); String line = \"\"; while ((line = reader.readLine()) != null) { sb.append(line); } } catch (IOException e) { LOGGER.error(\"流读取失败-request，request对象：{}，堆栈信息：{}\", request, e); } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { LOGGER.error(\"流关闭失败-request，request对象：{}，堆栈信息：{}\", request, e); } } if (reader != null) { try { reader.close(); } catch (IOException e) { LOGGER.error(\"流关闭失败-inputStream，inputStream：{}，堆栈信息：{}\", inputStream, e)); } } } return sb.toString(); }} 重写HttpServletRequestWrapper保存读到的流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.InputStreamReader;import java.nio.charset.Charset;public class ReHttpServletRequestWrapper extends HttpServletRequestWrapper { private final byte[] body; public ReHttpServletRequestWrapper(HttpServletRequest request) { super(request); body = HttpHelper.getBodyString(request).getBytes(Charset.forName(\"UTF-8\")); } @Override public BufferedReader getReader() { return new BufferedReader(new InputStreamReader(getInputStream())); } @Override public ServletInputStream getInputStream() { final ByteArrayInputStream basis = new ByteArrayInputStream(body); return new ServletInputStream() { @Override public int read() { return basis.read(); } @Override public boolean isFinished() { return false; } @Override public boolean isReady() { return false; } @Override public void setReadListener(ReadListener readListener) { } }; }} 信息回写到@RequestBody过滤器读取流时，如果发现@RequestBody中数据为空，获取存储在HttpServletRequest中的数据，回写到@RequestBody。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public abstract class AbstractCustomFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { Object result = run(request, response); if (result != null) { response.setCharacterEncoding(\"utf-8\"); PrintWriter out = response.getWriter(); out.print(result.toString()); out.flush(); out.close(); } else { ServletRequest requestWrapper; if (request instanceof HttpServletRequest) { requestWrapper = new ReHttpServletRequestWrapper(request); if (requestWrapper != null) { request = (HttpServletRequest) requestWrapper; } } filterChain.doFilter(request, response); } } /** * 过滤 * * @param request * @param response * @return */ protected abstract Object run(HttpServletRequest request, HttpServletResponse response);} 参考文献 @RequestBody参数已经被读取，究竟是何原因 拦截器拦截requestbody数据如何防止流被读取后数据丢失 解决使用@Requestbody时报错Stream closed document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"https://niithub.cn/tags/Spring/"},{"name":"流","slug":"流","permalink":"https://niithub.cn/tags/%E6%B5%81/"},{"name":"request","slug":"request","permalink":"https://niithub.cn/tags/request/"}]},{"title":"MySQL中的函数","date":"2020-11-11T14:40:15.000Z","path":"/posts/2881bb93/","text":"GROUP_CONCAT()语法：GROUP_CONCAT(row)作用：拼接同一个字段的多条记录 eg： 不使用函数 1select distinct service_name from service; 结果如下图所示： 使用函数后 1select group_concat(distinct service_name) from service; 结果如下图所示： DATEDIFF()语法：DATEDIFF(date1,date2)作用：计算两个日期的间隔，且只有值的日期部分参与计算 结果如下图所示： IFNULL()语法：IFNULL(expression, alt_value)作用：如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值。 eg: 使用函数前 1select card_id_a from table limit 1; 结果如下图所示： 使用函数后 1select IFNULL(card_id_a, '空') from table limit 1; 结果如下图所示： CURDATE()作用：返回当前的日期 1SELECT NOW(),CURDATE(),CURTIME(); 结果如下图所示： FLOOR()语法：FLOOR(X)作用：返回X的最大整数值，但不能大于X 1SELECT FLOOR(7.55); 结果如下图所示： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://niithub.cn/tags/MySQL/"},{"name":"函数","slug":"函数","permalink":"https://niithub.cn/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"MyBatis中的转义字符","date":"2020-11-11T13:43:48.000Z","path":"/posts/5f587efb/","text":"原字符 转义字符 说明 &lt; \\&lt; 小于 &lt;= \\&lt;= 小于或等于 &gt; \\&gt; 大于 &gt;= \\&gt;= 大于或等于 &lt;&gt; \\&lt;\\&gt; 不等于 &amp; \\&amp; 且 ‘ \\' 单引号 “ \\\" 双引号 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"转义字符","slug":"转义字符","permalink":"https://niithub.cn/tags/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://niithub.cn/tags/MyBatis/"}]},{"title":"读书笔记-202011","date":"2020-11-08T11:37:34.000Z","path":"/posts/54d67a1b/","text":"社会学研究乡村共同体重构与老年心理健康——农村老年心理干预的中国方案以下内容摘自乡村共同体重构与老年心理健康——农村老年心理干预的中国方案 当今农村家庭养老弱化,道德约束与公共监督的缺失是重要原因之一。家庭养老从伦理关系与文化传统的约束机制简化为经济上的计算与权衡,这不但深刻地影响着物质性养老的具体执行,更使得精神关怀严重匮乏,甚至导致老人为减轻子女负担而选择利他性自杀。这种养老策略从个体家庭泛化为整个农村社会的实践,同时乡土社会的碎片化也使得乡邻不愿干预他人的家事。两者叠加的结果是对养老的乡村公共监督逐渐消失。在本研究中,当整个村子对子女的养老行为公开加以评点议论时,褒善贬恶的舆论会在客观上产生影响,社会监督也逐渐形成。 老年互助在我国早已有之,民间互助团体如老人会在1949年之前较为常见依托地缘纽带和村落邻里关系形成的老年村民互助和相关道德话语,往往会在老年挫败感最强或不想活下去时产生缓解作用或带来转机。这是增强友邻关系可增进老人心理健康的重要原因。 第二个层面的友邻互助来自乡邻的他助。干预活动对全村所有人都产生了影响,唤醒与培育着全村善待老人的共同体文化与理念。 从另一层面而言,村干部成为守门人,在客观上被视为政府乃至国家的代表。在干预中有一项内容是发放“爱心联系卡”。 “爱心联系卡”上有老人信息和守门人的信息,发放给临界点老人和高危老人,主要用于当老人出现问题或突发危险时,他们或家人、周围的人能够根据卡片信息及时联系到守门人。为避免对老人产生标签化伤害和污名化,我们告诉老人:“卡片为随机发放,您正好被抽中。”事实表明,老人们非常乐意佩戴卡片;甚至没有被发放卡片的老人(心理问题较少的老人)会来问:“为什么我们没有卡?”当问及老人为什么愿意佩戴时,他们说:“这是国家关心我,我高兴呀!觉得国家、村里是真正地关心我,觉得活得有指望”。 在整个研究中,所有村民对干预研究最常见的评价是,“上面(国家)都关心老人了,我们也得关心呀!”这类话语口口相传,大家都深以为然,更内化为大家参与行动的合理性、正义性动机。尽管我们在项目中很少提及国家的态度,但人们会很自然地冠以“国家的名义”。这是研究开展初期的“未预结果”(unintended consequence)。 “国家的名义”让更多的普通人参与行动,同时也强化了老人获得国家关心的内在感受。农村老人对国家、集体主义有着特殊情怀。1949年至1978年间,我国建立了去自我、去家庭、去血缘的以“人民”为核心的共同体。这种集体主义生存方式在20世纪80年代改革开放后渐渐转变,进入21世纪后呈现快速消亡的趋势。中国当前的这一批老人恰恰是出生并成长在集体主义环境之中,或者说在他们的“个人生活中集体主义挥之不去”,因而在日常生活中比年轻一代更热衷于集体表征,也更乐于身处于集体之中。来自国家的关怀,或者说集体主义生存方式对于现在的农村老年人是一种潜在的、难以复制的情怀。我们的干预研究契合了老年人的这种情怀,对老年人而言,来自“上面”或者说“国家”及“政府”的关心,其意义更加深远。 在社会变迁下,礼治社会很难出现,这是乡土社会的特征。在传统礼治秩序面临冲击与瓦解的中国乡村中,公共生活与道德监督出现缺失(黄家亮,2018)。我们的研究一直被乡民们解读为“国家”关怀老人,村干部被视为政府权力代表,志愿者村民成为守望相助的邻人,老人自身与家人积极响应,其他村民深受感召,活动辐射到整个村庄。社会学研究通常承认,熟悉的人群中产生的道德约束与情感联系的强度与性质完全不同于陌生人群,对个体而言,社区共同体边界里面对面互动的熟悉的人群不仅常常是个体认知社会的基本场域、基本情景区,而且是个体在社会中满足与否的基本定位点、基本参照对象。当养老、爱老、敬老不再纸上谈兵,而是成为整个村子许多村民不断实践的日常过程时,其产生的道德约束就不再是空谈,每个置身于这个场域和情景的人不得不卷入其中,并重新认定这一规范对自己的作用与意义。 这类似于一个道德化的过程,“社区作为面对面交往的地方性共同体,隐蔽地嵌入个体意识的心理基础”,熟人社区中“不会消失的见证人”对个体形成道德约束和监督。社区中的道德声音作为他人的非正式赞同会形成一个非正式影响的关系网络,比国家力量更能为社会秩序提供道德基础。这一过程在一定程度上改变了私人生活不受监督、礼治秩序解体后孝道失范的状态。群体监督与规约的复出超越私人家庭,对子女产生监督作用,对全体乡邻爱老理念与行为产生激发与感召效应,初步唤醒了传统固有的与养老相关的内生性乡村文化,呈现出老年友好的乡村共同体文化特征。 在禄村书写文明——以圣谕坛为主线的复调民族志以下内容摘自在禄村书写文明——以圣谕坛为主线的复调民族志 宗教的作用之一,就是为混沌的世态赋予秩序。 人们在面对高度不确定性的环境时,需要将其归因为一套熟悉的话语系统,并通过可操作的程序来加以化解。而抗日战争期间的禄村,正是处在这样一个风云变幻的时局之中,所有这些看似荒诞不经的传说如果被“翻译”过来,表达的都是对社区外部环境不确定性的深深焦虑。 人们并不会用超自然的方式去应对能用技术解决的问题,恰恰是在那些无法用技术去解决的不确定领域,宗教和巫术才会粉墨登场。 民间宗教的兴起是中国历史上的一件大事,继佛、道、儒臻于成熟之后,“三教合一”的民间宗教成为中国人信仰世界的新增长点。凭借人人可行的道德来超越宿命和因果,是激发大批下层士人投身善书事业的重要心理动机。 政治***意识形态演变分析历史唯物主义认为,意识形态一般是指在一定的社会经济基础上形成的系统的思想观念,代表了某一阶级或社会集团的利益,又反过来指导这一阶级或集团的行动,可以给人提供采取特定行为的驱动力。 民族研究移动之悖:全球新冠疫情传播的人类学反思以下内容摘自在禄村书写文明——以圣谕坛为主线的复调民族志 任何社会里的个人生活,都是随着其年龄的增长,从一个阶段向另一个阶段移动的序列。 特定的动物、植物为原始人提供的食物关系;特定的动物、植物与原始人建立的亲合关系;图腾制度不只是一种文化现象,而是“自然条件的结果”。 考古怕辽代韩德让墓志考释以下内容摘自辽代韩德让墓志考释 瑶林琼树,不足拟其形容;璞玉浑金,不足知其名器。而又蜀龙顾凤,祢鹗徐麟,时瑞国祯,孰为等伦;乐水周山,宪陂邈海,风摽度量,孰测远大;边笥樗囊,丘墙张市,生知众望,孰能同类;谢兰绪柳,阮竹和松,岁寒风流,孰可比崇。其文也,鄙百家之异端,而师诸周孔,可以同三代之风;其武也,轻一夫之余勇,而慕彼关张,可以为万人之敌。其于九功九德,五礼五乐,三政三法,一话一言,二南二妙,六射六博,性习相近,好尚本异。是以在诸兄弟,独白眉以最良;袭乃公侯,才黑头而必复。加之以公忠许国,则致君亲垂其裳,迈帝皇王霸之道;以孝友承家,则使弟侄成其器,传将相侯伯之荣。以贞廉谨身,则不顾货财;以正直临事,则唯行阴德。以信义定交,则生者罔隔其贵贱,死者必恤其子孙。以谦和待士,则贤者縻之以好爵,俾其陈力就列;愚者诱之以善道,遣其进德修业。以宽仁御众,则喜愠讵形于颜色;以整肃率下,则言动不过于辞则。故得从始至末,自下升高。历事两朝,践履余二十任;总持二柄,周旋仅四十年。曾无间言,绰有余裕。其匡时之烈业,存于史谍;其盖世之勋庸,镂于鼎钟。虽力牧佐命于轩皇,皋陶矢谋于舜帝,伊尹作训于太甲,姬旦摄政于成王,萧相暨车千秋见重于炎汉,裴监与李世勣为荣于巨唐,彼我拟抡,羌不足同年而语矣!宜哉。箕子之所谓向用五福,而王年过贰膳,得不谓之寿乎?禄享万钟,得不谓之富乎?生平少疾患,得不谓之康宁乎?性分多庆善,得不谓之攸好德乎?成始卒之道,尽修短之限,得不谓之考终命乎?伟欤!富贵极矣!功德著矣!福寿全矣!哀荣备矣!以昔以今,未有如王之具美者矣!殁而无恨,藏也有期。英灵将閟于重泉,茂实是虞于高岸。宜刊贞石,用表佳城。陪以园陵,汉室庶传于扬秉;生其荆棘,雍门免叹于田文。呜乎哀哉! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"文章摘抄","slug":"文章摘抄","permalink":"https://niithub.cn/tags/%E6%96%87%E7%AB%A0%E6%91%98%E6%8A%84/"}]},{"title":"MySQL Explain","date":"2020-11-02T12:19:35.000Z","path":"/posts/142c8884/","text":"前言我们写完查询语句后，可以使用explain分析SQL语句的优劣，MySQL执行完explain后会输出SELECT 执行的详细信息。 1234567mysql&gt; explain select * from servers;+----+-------------+---------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | servers | ALL | NULL | NULL | NULL | NULL | 1 | NULL |+----+-------------+---------+------+---------------+------+---------+------+------+-------+1 row in set (0.03 sec) EXPLAIN输出说明 列名 说明 id SQL执行顺序。id相同的执行列可视为一组，同组的SQL语句执行顺序从上往下；在所有组中，id值越大，优先级越高，越先执行 select_type select子句的类型 table 表名 type 访问类型 possible_keys 可能使用的索引列，select查询涉及到的字段上若存在索引，则列出索引，但展示的索引不一定真的被使用 Key MySQL实际决定使用的索引 key_len 索引中使用的字节数，注意该字段显示的值为索引字段的最大可能长度，并非实际使用长度 ref 连接匹配条件 rows 连接匹配条件 extra 额外信息 select_type的详细解释 值名 解释 SIMPLE 简单SELECT,不使用UNION或子查询等 PRIMARY 查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY UNION UNION中的第二个或后面的SELECT语句 DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询 UNION RESULT UNION的结果 SUBQUERY 子查询中的第一个SELECT DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询 DERIVED 派生表的SELECT, FROM子句的子查询 UNCACHEABLE SUBQUERY 一个子查询的结果不能被缓存，必须重新评估外链接的第一行 type的详细解释TYPE表示MySQL在表中找到所需行的方式，又称“访问类型”，它是判断查询是否高效的重要依据依据。常用的类型有： ALL, index, range, index_subquery, unique_subquery, index_merge, ref_or_null, fulltext, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）。 值名 解释 Null 意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效） system 这是const连接类型的一种特例，表仅有一行满足条件 const 当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次 eq_ref 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果，通常在使用唯一性索引或主键查找时会发生, 查询效率较高 ref 此类型通常出现在多表的 join 查询, 此类索引访问只有使用非唯一性索引或唯一性索引非唯一性前缀时或使用了最左前缀规则索引。ref可以用于使用=或&lt;=&gt;操作符的带索引的列。 range 范围扫描，一个有限制的索引扫描，这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中. index index 类型则仅仅扫描所有的索引, 而不扫描数据 All 全表扫描 extra的详细解释 值名 解释 Using filesort 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果，查询时CPU消耗大，建议优化 Using temporary 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化 Using index 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错 Using index condition Using where 查询使用了where 语句来处理结果 Using join buffer 在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果，建议优化 impossible where 强调了where语句会导致没有符合条件的行 select tables optimized away 这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL分析","slug":"SQL分析","permalink":"https://niithub.cn/tags/SQL%E5%88%86%E6%9E%90/"},{"name":"优化","slug":"优化","permalink":"https://niithub.cn/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"SQL效率优化","date":"2020-11-02T06:48:18.000Z","path":"/posts/7b0c14fd/","text":"判断条件中值类型不同 问题产生原因如果where子句中的判断条件值类型不同，即 where a = b时，a的类型和b不相同，即使a有索引，索引也不会生效。 举例举例a的类型为varchar，且a列为索引列。where语句中使用a为条件查询时，where a = ‘3’，索引生效;当where a = 3，因为3的数据类型为int，字段a的类型为varchar，所以MySQL会自动将3转换成varchar，同时索引失效。 解决办法使用CONVERT()函数转换参数值类型，使值类型一致。 CONVERT()语法 CONVERT(value, type) CONVERT(value USING charset) type支持的类型: 参数 描述 DATE 参数类型转换成DATE，”YYYY-MM-DD” DATETIME 参数类型转换成DATETIME，”YYYY-MM-DD HH:MM:SS” DECIMAL 参数类型转换成数据类型，DECIMAL(M,D)，M是数据总长度（默认值是10），D是小数位长度 TIME 参数类型转换成TIME，”HH:MM:SS” CHAR 参数类型转换成固定长度的字符 NCHAR 参数类型转换成使用国家编码集的字符型 SIGNED 参数类型转换成64-bit的整型 UNSIGNED 参数类型转换成64-bit的无符号整型 BINARY 参数类型转换成二进制字符 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"优化","slug":"优化","permalink":"https://niithub.cn/tags/%E4%BC%98%E5%8C%96/"},{"name":"SQL","slug":"SQL","permalink":"https://niithub.cn/tags/SQL/"},{"name":"索引","slug":"索引","permalink":"https://niithub.cn/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"Java-Stream使用记录","date":"2020-11-02T06:46:31.000Z","path":"/posts/251bc8b7/","text":"Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了。和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。 Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。 流的特性包括： 没有内部存储，只是用操作管道从 source（数据结构、数组、generator function、IO channel）获取数据。 它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 所有 Stream 的操作必须以 lambda 表达式为参数 不支持索引访问 你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。 很容易生成数组或者 List 惰性化 很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。 Intermediate 操作永远是惰性化的 并行能力 当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。 Stream流当我们使用一个流的时候，通常包括三个基本步骤： 获取一个数据源（source） 数据转换 执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。 生成流的方式Collection和数组 Collection.stream() Collection.parallelStream() Arrays.stream(T array) or Stream.of() BufferedReader java.io.BufferedReader.lines() 静态工厂 java.util.stream.IntStream.range() java.nio.file.Files.walk() 自己构建 java.util.Spliterator 其它 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 流的操作类型Intermediate一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），不会消耗流，就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 操作示例1234int sum = widgets.stream() .filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); stream()获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。 流的使用 对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果。 构造流的方式 123456789// 1. Individual valuesStream stream = Stream.of(\"a\", \"b\", \"c\");// 2. ArraysString [] strArray = new String[] {\"a\", \"b\", \"c\"};stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream(); 流转换成其他数据结构 123456789// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString(); 流的操作 Intermediate map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Terminal forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator Short-circuiting anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 流的使用详解Collect结果 map(一对一)：作用是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素 flatMap(一对多)：flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数据。 filter：filter 对原始 Stream 进行某项过滤，通过过滤的元素被留下来生成一个新 Stream。 123Integer[] sixNums = {1, 2, 3, 4, 5, 6};Integer[] evens = Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new); forEach：forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。forEach 是 terminal 操作，因此它执行后，Stream 的元素就被”消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 findFirst： termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空，注意：返回值类型：Optional，使用它的目的是尽可能避免 NullPointerException。 reduce：主要作用是把 Stream 元素组合起来。它提供一个起始值，然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。 123456789101112// 字符串连接，concat = \"ABCD\"String concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat);// 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);// 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = \"ace\"concat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").filter(x -&gt; x.compareTo(\"Z\") &gt; 0).reduce(\"\", String::concat); limit/skip：limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。 allMatch：Stream 中全部元素符合传入的 predicate，返回 true anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true 123Predicate&lt;Integer&gt; predicate = i -&gt; i % 2 == 0;Stream stream = Stream.of(1, 2, 5);Assert.isTrue(stream.anyMatch(predicate)); noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true 收集器 收集1List.of(1, 2, 3).stream().collect(Collectors.toList()); Grouping 和 PartitioninggroupingBy 根据某一个字段或条件进行分组，返回一个 Map，其中 key 为分组的字段或条件，value 默认为 list，groupingByConcurrent() 是其并发版本 12345Map&lt;String, List&lt;DataMap&gt;&gt; ids = list.stream().collect(Collectors.groupingBy(p -&gt; p.getString(\"id\")));``` - 如果 groupingBy() 分组的依据是一个 bool 条件，则 key 的值为 true/false ，此时与 partitioningBy() 等价，但效率不如partitioningBy Map&lt;Boolean, List&gt; result = list.stream().collect(Collectors.groupingBy(p -&gt; p.getString(“id”).equalsIgnoreCase(“name”))); 123456- groupingBy()也支持两个入参，后一个参数可对分组后的 value 作进一步的处理 - 结果集返回Set ```JAVA Map&lt;String, List&lt;DataMap&gt;&gt; ids = list.stream().collect(Collectors.groupingBy(p -&gt; p.getString(\"id\"), Collectors.toSet())); 返回 value 集合中元素的数量1Map&lt;String, List&lt;DataMap&gt;&gt; ids = list.stream().collect(Collectors.groupingBy(p -&gt; p.getString(\"id\"), Collectors.counting())); partitioningBy返回值是boolean类型的，且返回值只能将数据分为两组也就是ture和false两组数据 1Map&lt;Boolean, List&lt;DataMap&gt;&gt; result = list.stream().collect(Collectors.partitioningBy(p -&gt; p.getString(\"id\").equalsIgnoreCase(\"name\"))); 参考文献 使用 Java 8 中的 Stream java-stream-filter-lambda Java Stream Filter with Lambda Expression Java8收集器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Stream","slug":"Stream","permalink":"https://niithub.cn/tags/Stream/"}]},{"title":"Java延迟阻塞队列-DelayQueue","date":"2020-10-10T06:57:57.000Z","path":"/posts/eb2269ad/","text":"引言DelayQueue是java.util.concurrent包中提供的无界延迟阻塞队列，可以被应用于生产者、消费者项目。DelayQueue中的元素只有在剩余存活时间为0后，才可以被消费者获取到。队列中元素的剩余存活时间升序排列。 1public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; 1234567891011public interface Delayed extends Comparable&lt;Delayed&gt; { /** * Returns the remaining delay associated with this object, in the * given time unit. * * @param unit the time unit * @return the remaining delay; zero or negative values indicate * that the delay has already elapsed */ long getDelay(TimeUnit unit);} DelayQueue的使用DelayQueue类提供了两个构造方法，一个是无参构造方法，一个是从其他集合中获取元素。 12DelayQueue()DelayQueue(Collection&lt;? extends E&gt; c) DelayQueue的节点元素由于DelayQueue只能从Delayed类中获取元素，所以我们可以像下面这样创建一个节点-DelayedElement： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.concurrent.Delayed;import java.util.concurrent.TimeUnit;/** * @author : niithub * @description : 延迟队列里的对象元素 * @date : 2020/10/10 */public class DelayedElement implements Delayed { private String name; // 元素在队列中存活时长 private final Long delay; // 元素出队时间节点 private final Long expire; // 元素入队时间节点 private final Long now; public DelayedElement(String name, Long delay) { this.name = name; this.delay = delay; expire = System.currentTimeMillis() + delay; now = System.currentTimeMillis(); } /** * 获得延迟时间 * * @param unit * @return */ public long getDelay(TimeUnit unit) { return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS); } /** * 通过比较存活时间排序 * * @param o * @return */ public int compareTo(Delayed o) { DelayedElement delayedElement = (DelayedElement) o; if (this.expire &lt; delayedElement.expire) { return -1; } if (this.expire &gt; delayedElement.expire) { return 1; } return 0; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\"DelayedElement{\"); sb.append(\"delay=\").append(delay); sb.append(\", expire=\").append(expire); sb.append(\", now=\").append(now); sb.append('}'); return sb.toString(); }} 上例中可以看出，构造函数中接收外部传入的元素存活时间delay，构造函数中计算出expire-元素的出队时间。getDelay()方法返回该元素的剩余存活时间，时间单位可自由设定。当消费者使用poll()或take()从队列中获取元素时，DelayQueue将执行getDelay()方法，计算队列的头结点剩余存活时间，判断头结点是否允许出队，即能否被消费者获取到。当getDelay()返回0时，头结点可以出队，消费者能顺利获取到元素；当getDelay()返回负数时，表明头结点仍有存活时间，队列阻塞。 创建DelayQueue 方法11DelayQueue&lt;DelayedElement&gt; queue = new DelayQueue&lt;&gt;(); 方法212List&lt;DelayedElement&gt; listTask = ... // a list of DelayTask objectsDelayQueue&lt;DelayedElement&gt; queue = new DelayQueue&lt;&gt;(listTask); 向队列中插入元素 DelayQueue为入队操作提供了两个方法，put()和offer()。 返回值 方法名 描述 boolean offer(E e) 向delayQueue中插入元素 boolean offer(E e, long timeout, TimeUnit unit) 向delayQueue中插入元素 void put(E e) 向delayQueue中插入元素 1234567DelayedElement task1 = new DelayedElement(\"Learn Java\", 20_000);DelayedElement task2 = new DelayedElement(\"Code Java\", 100_000);DelayedElement task3 = new DelayedElement(\"Do Project\", 200_000); queue.offer(task1);queue.offer(task2);queue.offer(task3); 从阻塞队列中获取元素DelayQueue为获取元素操作同样提供了三个方法，poll()、take()和peek()。 返回值 方法名 描述 E take() 检索并删除此队列的头结点，如果当前队列中元素均还在存活时间内，则阻塞当前队列直至某个元素的存活时间失效 E poll() 检索并删除此队列的头结点，如果该队列没有延迟过期的元素，则返回null。 E peek() 检索但不删除此队列的头结点，如果此队列为空，则返回null。与轮询不同，如果队列中没有过期的元素可用，此方法将返回下一个过期的元素(如果存在的话)。 1234567DelayedElement task = queue.poll(); if (task != null) { System.out.println(\"Process: \" + task);} else { System.out.println(\"No expired task\");} 123456try { DelayedElement task = queue.take(); System.out.println(\"Process: \" + task);} catch (InterruptedException e) { e.printStackTrace();} 1234567DelayedElement task = queue.peek(); if (task != null) { System.out.println(\"Process: \" + task);} else { System.out.println(\"Queue is empty\");} 生产者/消费者模式示例生产者 DelayQueueProducer类的run()被调用时，元素入队。 1234567891011121314151617181920212223242526272829303132import java.util.*;import java.util.concurrent.*; public class Producer extends Thread { private DelayQueue&lt;DelayedElement&gt; queue; private static int taskCount; public Producer(DelayQueue&lt;DelayedElement&gt; queue) { this.queue = queue; } public void run() { while(true) { queue.put(produce()); } } private DelayedElement produce() { String taskName = \"Task \" + (++taskCount); long delayTime = new Random().nextInt(10000); try { Thread.sleep(1000); } catch (InterruptedException ie) { ie.printStackTrace(); } System.out.println(getName() + \": produced \" + taskName); return new DelayedElement(taskName, delayTime); }} 消费者 12345678910111213141516171819202122232425import java.util.concurrent.*;public class Consumer extends Thread { private DelayQueue&lt;DelayedElement&gt; queue; private int taskCount; public Consumer(DelayQueue&lt;DelayedElement&gt; queue) { this.queue = queue; } public void run() { while(true) { try { DelayedElement task = queue.take(); consume(task); } catch (InterruptedException ie) { ie.printStackTrace(); } } } private void consume(DelayedElement task) { System.out.println(getName() + \": prepare to process \" + task); task.run(); }} 测试 12345678910111213141516171819import java.util.concurrent.*; public class DelayQueueTest { static int CONSUMER_THREADS = 3; public static void main(String[] args) { DelayQueue&lt;DelayedElement&gt; queueTasks = new DelayQueue&lt;&gt;(); Producer producer = new Producer(queueTasks); producer.start(); Consumer[] consumers = new Consumer[CONSUMER_THREADS]; for (int i = 0; i &lt; CONSUMER_THREADS; i++) { consumers[0] = new Consumer(queueTasks); consumers[0].start(); } }} 参考 Java DelayQueue Examples 延迟队列 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"阻塞队列","slug":"阻塞队列","permalink":"https://niithub.cn/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"},{"name":"Queue","slug":"Queue","permalink":"https://niithub.cn/tags/Queue/"}]},{"title":"解决JVM_Bind Error","date":"2020-09-23T12:26:05.000Z","path":"/posts/6ae395c2/","text":"问题 在使用IDEA重启Java项目时，有时会遇到下面这个错误： 1Address already in use: JVM_Bind 原因 从错误提示字面意思理解是当前Application想绑定的端口已经被其他被的Application监听了，所以JVM才会抛出这个异常。 Java程序需要一定的时间来完成中止运行操作，如果在你点restart的时候程序还在操作数据库，那么该程序在完成操作之前会一直保持数据库链接。 基于上述原因，有时我们在IDEA中restart项目后，会遇到JVM_Bind这个错误。 解决办法 （预防方法）不使用restart来重启项目，选择先stop项目，等个5s左右在run 杀进监听你想绑定的那个端口的进程 Windows 使用下面这个命令来查找某个端口对应的PID 1C:\\&gt;netstat -ano | find \"8080\" 一般结果会是这样的： 1TCP 0.0.0.0:8080 0.0.0.0:0 LISTENING 26732 26732就是8080端口对应的PID，手动杀死该进程 1taskkill /f /pid 26732 Linux 查找端口对应的PID 1trader@asia:~ netstat -nap | grep 8080 手动杀死该进程 1kill -s 9 13279 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Windows","slug":"Windows","permalink":"https://niithub.cn/tags/Windows/"},{"name":"端口占用","slug":"端口占用","permalink":"https://niithub.cn/tags/%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/"},{"name":"IDEA","slug":"IDEA","permalink":"https://niithub.cn/tags/IDEA/"}]},{"title":"使用jsDelivr加速Github仓库","date":"2020-09-22T12:21:34.000Z","path":"/posts/fc2f9574/","text":"JSDelivr是国外的一家优秀的公共 CDN 服务提供商，也是首个「打通中国大陆（网宿公司运营）与海外的免费 CDN 服务」。JSDelivr的CDN节点可以引用的资源有Npm、Github、WordPress等，因此，我们可以使用JSDelivr来为我们的Github仓库提供CDN加速。注意：Github仓库体积需小于50M。 通过访问符合JSDelivr规则的URL，我们就可访问到JSDelivr的CDN节点提供的资源。详细规则可参考官网。 URL标识分类 Npm加速链接 1https://cdn.jsdelivr.net/npm/package@version/file Github加速链接 1https://cdn.jsdelivr.net/gh/user/repo@version/file WordPress加速链接 1https://cdn.jsdelivr.net/wp/plugins/project/tags/version/file Github资源加速链接示例 用户名/仓库名@版本号/文件名 12// load jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js 通过上面这个链接，我们可以经由JSDelivr的CDN节点访问到用户jquery的jquery仓库，具体访问的是版本为3.2.1的jquery仓库的dist文件夹下的jquery.min.js文件。 如果加速链接中忽略版本号，则默认访问仓库的master分支。 在任意JS/CSS文件后添加.min能得到一个缩小版 12// load min jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js 如果访问的目标仓库对应地址中只有core.js这个文件，而没有core.min.js，JSDelivr会自动生成一个min.js。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"CDN","slug":"CDN","permalink":"https://niithub.cn/tags/CDN/"},{"name":"Github","slug":"Github","permalink":"https://niithub.cn/tags/Github/"}]},{"title":"MySQL-解除安全模式","date":"2020-09-21T12:55:04.000Z","path":"/posts/5cbc292c/","text":"问题有时我们在使用SQL修改数据库中数据时，会遇到下面的错误提示：1Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Editor and reconnect. 原因产生这个问题的原因是MySQL开启了“安全修改”模式-“–safe-updates”,MySQL的官方文档中指出，开启了“安全修改”模式后，UPDATE和DELETE操作必须在WHERE条件或LIMIT条件中显式使用key来映射待操作的数据行。如果不显式使用key指定数据，MySQL就会报错。此外，该模式还对产生(或可能产生)非常大的结果集的SELECT语句施加了限制。 解决方案关闭“安全修改”模式 1SET SQL_SAFE_UPDATES=0; 在条件中显式声明key 在WHERE条件或LIMIT条件中显式声明key document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://niithub.cn/tags/MySQL/"}]},{"title":"在遍历中删除List的元素","date":"2020-09-21T12:31:49.000Z","path":"/posts/5136b1ee/","text":"遍历链表/数组的三种方式 Iterator遍历 123456789...Iterator iterator = list.iterator();while (iterator.hasNext()) { ... // 如果想获取迭代器中的元素 Object cur = iterator.next(); ...}... for循环遍历 123for(int i = 0; i &lt; list.size(); i ++) { System.out.println(list.get(i));} 增强型for循环遍历 123for(String tmp: list) { System.out.println(tmp);} 两种错误的在遍历中删除元素的方式 for循环顺序遍历 直接使用简单for循环，以for (int i = 0; i &lt; list.size(); i++) 进行遍历，这种方式可能会在遍历的过程中漏掉部分元素，从而出现少删的情况。 12345678910111213141516171819/** * 假设list初始长度为4，{1,2,3,4}，element元素为2 * 第二个元素满足条件被删掉，此时下标i为1，且原有的数组的第三个元素，变成了新数组的第二个元素 * 新数组为{1,3,4} * 自增后i=2,但下标为2此时指向的是新数组中的第三个元素，即原数组中的第四个元素 * `原数组中的第三个元素就被漏掉了` * * @param list * @param element * @return */public static List forRemove(List list, Object element) { for (int i = 0; i &lt; list.size(); i++) { if (element.equals(list.get(i))) { list.remove(i); } } return list;} 增强型for循环遍历 使用增强for循环时，如果删除后继续向下循环则会报java.util.ConcurrentModificationException 12345Exception in thread \"main\" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at com.lingyejun.leetcode.RemoveListElement.forceForRemove(RemoveListElement.java:57) at com.lingyejun.leetcode.RemoveListElement.main(RemoveListElement.java:112) 在遍历中删除元素的两种正确示例 Iterator遍历 12345678Iterator iterator = list.iterator();while (iterator.hasNext()) { Object cur = iterator.next(); if (cur.equals(element)) { // 这里是Iterator.remove()，而不是list.remove() iterator.remove(); }} 增强型for循环删除元素后break 使用增强for循环，删除元素后，立即跳出，则正常退出，但缺点是不能向后继续循环了。 123456for (Object item : list) { if (item.equals(element)) { list.remove(item); break; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"https://niithub.cn/tags/Java/"},{"name":"List","slug":"List","permalink":"https://niithub.cn/tags/List/"}]},{"title":"Git设置代理","date":"2020-09-14T12:37:16.000Z","path":"/posts/cb59751e/","text":"查看本地代理服务器的端口 以v2rayN为例，查看本地代理服务器端口的方法为打开v2rayN的安装目录，查看config.json文件。 123456789101112131415161718192021222324252627 { ... \"inbounds\": [ { \"tag\": \"proxy\", \"port\": 10919, \"listen\": \"127.0.0.1\", \"protocol\": \"socks\", \"sniffing\": { \"enabled\": true, \"destOverride\": [ \"http\", \"tls\" ] }, \"settings\": { \"auth\": \"noauth\", \"udp\": true, \"ip\": null, \"address\": null, \"clients\": null }, \"streamSettings\": null } ] ...} 上述JSON代码中，指出本地代理服务器使用的协议为Socket5，代理端口为10919。 为Git配置代理 Git 同时支持Socket5和HTTP代理，具体配置根据本地代理服务器实际情况配置即可。 Socket5 代理 Git 默认的 Socket5 代理应设置为：(${server}是服务器地址，${port}是代理端口) 12 git config --global http.proxy socks5://${server}:{port}git config --global https.proxy socks5://${server}:{port} 以我本地服务器设置为例，设置代理的具体代码为： 12git config --global http.proxy socks5://127.0.0.1:10919git config --global https.proxy socks5://127.0.0.1:10919 HTTP代理 12git config --global http.proxy http://${server}:{port}git config --global https.proxy https://${server}:{port} 以我本地服务器设置为例，设置代理的具体代码为： 12git config --global http.proxy http://127.0.0.1:10919git config --global https.proxy https://127.0.0.1:10919 取消代理设置 12git config --global --unset http.proxy git config --global --unset https.proxy document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设置","slug":"设置","permalink":"https://niithub.cn/tags/%E8%AE%BE%E7%BD%AE/"},{"name":"Git","slug":"Git","permalink":"https://niithub.cn/tags/Git/"},{"name":"VPN","slug":"VPN","permalink":"https://niithub.cn/tags/VPN/"}]},{"title":"Spring-基于注解的缓存","date":"2020-09-02T12:27:12.000Z","path":"/posts/4592c72b/","text":"从3.1版本开始，Spring引入了对Cache的支持，还提供了@Cacheable、@CacheEvict、@CachePut、@Caching、@CacheConfig注解操作Cache。 @Cacheable: 触发将信息存入缓存的操作@CacheEvict: 触发从缓存中删除特定已缓存信息的操作CachePut: 在不干扰方法执行的同时，更新缓存信息@Caching: 可以让一个方法同时使用多个嵌套的@Cacheable、@CachePut、@CacheEvict注解@CacheConfig: 在类这一级别上共享一些常见的缓存相关设置 可以通过在@Configuration类使用@EnableCaching注解的方式开启Spring Cache的控制。 1234@Configuration@EnableCachingpublic class AppConfig {} @Cacheable说明 可以标记在一个方法上，也可以标记在类上，当标记在类上时，当前类的所有方法都支持缓存 当注解的方法被调用时，如果缓存中有值，则直接返回缓存中的数据 参数 作用 value 缓存的空间名称，必须指定，Value值可以是一个Cache也可以是多个Cache，当需要指定多个Cache时，value写作成一个数组。也可以用cacheNames指定空间名称。 key 缓存的key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合。同一个空间名称value下的key唯一。 condition 缓存的条件，默认为true，使用 SpEL 编写，返回true或者false，只有为true才进行缓存。为true时：如果缓存有值，则不执行方法；如果缓存没值，则执行方法并将结果保存到缓存。为false时：不执行缓存，每次都执行方法。 例子value的使用12@Cacheable(\"books\")public Book findBook(ISBN isbn) {...} 12@Cacheable({\"books1\", \"books2\"})public Book findBook(ISBN isbn) {...} 12@Cacheable(value=\"books\")public Book findBook(String isbn) {...} 12@Cacheable(CacaheNames=\"books\")public Book findBook(String isbn) {...} 以上三种注解的使用结果是相同的，此时如果查询缓存，查询的key一般为books/{isbn}。每次findBook方法被调用时，都会先检查缓存中是否已有Book数据，如果已经有Book数据，则直接返回数据，而不是重复执行findBook方法。 key的使用12@Cacheable(value=\"books\", key=\"isbn + '_' + #id\")public Book findBook(String isbn, Integer id) {...} 当isbn=”book0101”, id=002时，查询缓存所需要的key一般为 books/book0101_002。 condition的使用12@Cacheable(cacheNames = \"books\", key = \"'book_'+ #id\", condition = \"#id &gt; 100\")public Book findBook(String isbn, Integer id) {...} 上例表示只有当id大于100时才开启缓存，缓存空间名为books，缓存的key为’book_’+#id，即当传入的id为101时,查询缓存的key为books/book_101。 @CachePut说明与@Cacheable不同的是，@CachePut是一个方法注解，使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。 参数 作用 key 同@Cacheable value 同@Cacheable condition 和@Cacheable区别是，无论是true还是false都会执行方法 例子12@CachePut(value = \"books\", key = \"'book_'+#id\", condition = \"#id &gt; 100\")public Book findBook(String isbn, Integer id) {...} 上例表示当id大于100时开启缓存，缓存空间名为books，缓存的key为’book_’+#id @CacheEvict说明 @CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。 @CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。 参数 作用 value 同@Cacheable key 同@Cacheable condition 缓存的条件，可以为空，使用 SpEL 编写，返回true或者false，只有为 true 才进行缓存。 allEntries 是否清空所有缓存内容，默认为 false。如果为 true，则方法调用后将清空指定value空间下的所有缓存。 beforeInvocation 是否在方法执行前就清空，默认为false。如果为true，则在方法执行前就清空缓存。为false时，如果方法执行抛出异常，则不会清空缓存。 例子allEntries的使用12@CacheEvict(value=\"users\", allEntries=true)public void delete(Integer id) {} 上例表示清除缓存空间名为’users’的缓存中的所有数据。 beforeInvocation的使用12@CacheEvict(value=\"users\", beforeInvocation=true)public void delete(Integer id) {} @Caching说明 @Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。 拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict 例子12@Caching(cacheable = @Cacheable(\"users\"), evict = { @CacheEvict(\"cache2\"),@CacheEvict(value = \"cache3\", allEntries = true) })public User find(Integer id) {} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"注解","slug":"注解","permalink":"https://niithub.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"Spring","slug":"Spring","permalink":"https://niithub.cn/tags/Spring/"},{"name":"缓存","slug":"缓存","permalink":"https://niithub.cn/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"Centos开启中文输入法","date":"2020-08-20T02:07:07.000Z","path":"/posts/d4ca125/","text":"Centos系统中自带中文输入法-智能拼音，开启中文输入法的操作步骤如下：Applications –&gt; System Tools –&gt; Setting –&gt; Region &amp; Language – &gt; Input Source 点击”+”，找到 Chinese(china) ，选择”汉语(Itelligent Pinyin)” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://niithub.cn/tags/CentOS/"},{"name":"设置","slug":"设置","permalink":"https://niithub.cn/tags/%E8%AE%BE%E7%BD%AE/"}]},{"title":"Linux必要安装配置","date":"2020-08-19T06:22:31.000Z","path":"/posts/f31f360f/","text":"安装图形化界面 1yum groupinstall GNOME Desktop 配置yum源 123456cd /etc/yum.repos.d/sudo mv CentOS-Base.repo CentOS-Base.repo_baksudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecache 安装Node.js 安装 12https://nodejs.org/dist/latest-v10.x/node-v10.24.1-linux-x64.tar.xztar -xf node-v8.11.1-linux-x64.tar.xz --directory /usr/local --strip-components 1 配置 123npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config set puppeteer_download_host https://npm.taobao.org/mirrors 安装git 下载git 1yum -t install git 配置git 1234git config --global user.name yourNamegit config --global user.email yourEmailgit config --global http.sslverify falsegit config --global https.sslverify false 生成密钥 1ssh-keygen -t rsa -C \"yourEmail\" 安装Nginx 添加Nginx存储库 1sudo yum install epel-release 安装Nginx 1sudo yum install nginx 启动Nginx 1sudo systemctl start nginx 重启Nginx 1service nginx restart 开机自启动Nginx 1sudo systemctl enable nginx 字符集修改 进入配置目录 1cd /etc/sysconfig/ 修改字符集 12sudo vi i18nLANG='zh_CN.utf8' 读取更改后的配置 1source /etc/sysconfig/i18n document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://niithub.cn/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"https://niithub.cn/tags/Linux/"},{"name":"安装记录","slug":"安装记录","permalink":"https://niithub.cn/tags/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"}]},{"title":"PostConstruct注解","date":"2020-07-24T07:00:43.000Z","path":"/posts/c710e893/","text":"从Java EE5规范开始，Servlet中增加了影响Servlet生命周期的注解，@PostConstruct，这个注解用来修饰方法，并且在依赖注入后执行初始化操作。这个注解可以在所有的类上使用，即使这个类没有请求任何资源，使用@PostConstruct注解的方法也可以被注入。 注意：一个类中只能使用该注解一次。 通常使用该注解在static方法中注入bean：1234567891011121314151617181920212223@Componentpublic class DSHWechatApiUtil {&nbsp;&nbsp;&nbsp; @Autowired&nbsp;&nbsp;&nbsp; private ParamConfig paramConfig; @Autowired private static ParamConfig staticParamConfig; @PostConstruct public void init() { staticParamConfig = paramConfig; } public static JSONObject example() { JSONObject returnObject = new JSONObject(); try { returnObject = staticParamConfig.doSomething(...); } catch (Exception e) { e.printStackTrace(); } return returnObject; }} 使用@PostConstruct 注解的方法必须遵循以下规范： 该方法不得有任何参数，除非是在 EJB 拦截器 (interceptor) 的情况下，根据 EJB 规范的定义，在这种情况下它将带有一个 InvocationContext对象 该方法的返回类型必须为 void 使用@PostConstruct注解的方法访问控制符可以是 public、protected、package private 或 private； 使用@PostConstruct有如下两种方式： Method 1: 12@PostConstructpublic void someMethod(){} Method 2: 1public @PostConstruct void someMethod(){} 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。@PostConstruct在构造函数之后执行，init（）方法之前执行，生命周期如下图所示： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"https://niithub.cn/tags/Java/"},{"name":"注解","slug":"注解","permalink":"https://niithub.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"MySQL之replace into()","date":"2020-07-23T07:15:00.000Z","path":"/posts/5f13f7b7/","text":"REPLACE()是MySQL数据库对普通SQL的扩展，该函数主要运用在以下场景：往存在主键或唯一索引的表中插入一条新数据，如果原表中已经有此行数据（根据主键或唯一索引判断），则删除原数据后插入新数据，若未发现主键重复或唯一索引重复则直接插入原数据。 注：MySQL使用主键或唯一索引来辨别要插入的新数据是否已经在原表中存在，如果待操作的表不存在主键或唯一索引，则REPLACE()将像INSERT()执行。 在对表执行REPLACE()时，你需要至少拥有INSERT和DELETE权限。 使用REPLACE往MySQL中插入一行新数据 下面是REPLACE的语法: 1REPLACE [INTO] table_name(column_list) VALUES(value_list); 除了REPLACE和INSERT不同外，其他地方很像插入语句。 让我们通过一个例子来看看REPLACE函数的执行过程。 首先建立一张名为cities的表： 12345CREATE TABLE cities ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(50), population INT NOT NULL); 往表中插入一些数据： 1234567INSERTINTO cities (name, population)VALUES ('New York', 8008278), ('Los Angeles', 3694825), ('San Diego', 1223405); 执行查询操作，以验证数据是否插入成功。 1SELECT * FROM cities; 使用REPLACE()将Los Angeles的人口数改为3696820: 1REPLACE INTO cities(id,population) VALUES(2,3696820); 再次查询，验证使用REPLACE()修改是否生效。 修改列的name字段值变为NULL，REPLACE()的执行过程如下所示： 首先，REPLACE()试图往表中插入一条新的数据，由于id=2已经存在，所以插入操作执行失败。 REPLACE()删除原有的id=2的这行数据，插入了一行新的id=2,population=3696820的数据，由于在REPLACE语句中未定义name的值，所以新数据行name为NULL。 使用REPLACE修改MySQL中的数据 使用REPLACE修改时，所用语法如下所示： 12REPLACE INTO tableSET column1 = value1, column2 = value2; 语法和UPDATE语句很像，但REPLACE的语法中没有WHERE条件子句。下面这个例子将使用REPLACE把id=2的数据修改为下面所示。 1234REPLACE INTO citiesSET id = 2, name = 'Phoenix', population = 1768980; 和UPDATE语句不同的是，如果在SET子句中没有指定列的值，REPLACE语句将为该列赋予默认值。 执行查询操作，以验证数据修改操作是否成功。 使用REPLACE插入SELECT查询出的数据信息使用REPLACE插入SELECT查询出的信息时，所用语法如下所示：1234REPLACE INTO table_1(column_list)SELECT column_listFROM table_2WHERE where_condition; 同样的，上述语法和INSERT INTO SELECT的语法有点相似。 接下来我们用REPLACE INTO来复制cities表中id=1的行数据。 12345678REPLACE INTO cities(name,population)SELECT name, population FROM cities WHERE id = 1; 执行查询操作，以验证数据复制操作是否成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://niithub.cn/tags/MySQL/"},{"name":"函数","slug":"函数","permalink":"https://niithub.cn/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"MySQL之FIND_IN_SET()函数的使用","date":"2020-07-22T07:14:00.000Z","path":"/posts/725ce6e3/","text":"MySQL提供了一个名为 FIND_IN_SET() 的内置字符串函数，允许您在逗号分隔的字符串列表中查找指定字符串的位置。 该函数的语法：FIND_IN_SET(str, strlist)str为要查询的字符串，strlist为目标字符串，参数以,分隔，如(1,2,3,4)。 函数查询结果为null或元素位置，当str/strlist任意一个参数为null时，函数返回值为null；当strlist中不包含str或strlist为空字符串时，函数返回值为0；当str中包含,时函数将无法运行。 123456MySQL&gt; SELECT find_in_set('2', '1,2,3,4'); -&gt; 2MySQL&gt; SELECT find_in_set('6', '1'); -&gt; 0MySQL&gt; SELECT find_in_set('2', null); -&gt; NULL document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://niithub.cn/tags/MySQL/"},{"name":"函数","slug":"函数","permalink":"https://niithub.cn/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"直接插入排序","date":"2019-08-05T08:36:00.000Z","path":"/posts/2b06d603/","text":"基本知识 直接插入排序的最好情况下时间复杂度为O(n)，最坏情况下时间复杂度为O(n^2)。 直接插入排序只需要一个记录的辅助空间，其空间复杂度为O(1) 直接插入排序是稳定的排序算法，适用于待排序记录数较少且基本有效的情况。当待排序的记录数目过多时，插入排序的性能直线下降。 举例 假如8个记录的关键字序列为（56, 68, 25, 45, 90, 38, 10, 72） 基本思想 插入前需要找到插入位置，移动记录空出插入位置，第i趟插入排序将记录L.rcd[i+1]插入到有序区L.rcd[1..i]中 其中中括号中的序列表示有序序列，中括号后面的序列表示无序序列，每一趟的直接插入排序就是将无序序列中的第一个记录，即待插入记录，插入到有序序列中的合适位置，使得有序序列的长度增加一个，只包含一个记录的序列是有序的，因此第一趟插入排序是将存储在2号单元的记录插入到前面有序序列中去。 首先需要查找插入位置，查找插入位置，可以在有序序列中从前到后进行查找，也可以从后向前进行查找，查找结束，发现待插入记录38应插入到记录25和45之间，若要实现插入操作，还需要将记录45到90向后移动一个位置, 以空出插入位置，将记录38插入。 在移动记录时，若选择从前到后的顺序移动记录，后面的记录会被覆盖，因此必须从后向前移动记录，记录90向后移动时，会覆盖掉待插入记录38，因此，移动前还需要将记录38暂存他处。 那么对应第i趟插入排序，就是将存储在i+1号单元的待插入记录插入到有序区[1..i]号单元的合适位置中，很显然要实现该算法，插入前需要找到插入位置，移动记录空出插入位置。 核心程序实现 c 123456789101112131415161718void InsertSort(RcdSqList &amp;L) { // 对顺序表L作直接插入排序。 int i, j; for (i = 1; i&lt;L.length; ++i) { if(L.rcd[i+1].key&lt;L.rcd[i].key) { // 需将L.rcd[i+1]插入有序序列 L.rcd[0] = L.rcd[i+1]; // 先将记录L.rcd[i+1]保存在空闲的0号单元 j = i+1; do { j--; L.rcd[j+1] = L.rcd[j]; // 记录后移 } while(L.rcd[0].key&lt;L.rcd[j-1].key); // 判断是否需要继续移动 L.rcd[j] = L.rcd[0]; // 插入 } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"插入排序","slug":"插入排序","permalink":"https://niithub.cn/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}]},{"title":"排序算法","date":"2019-08-05T08:14:00.000Z","path":"/posts/735e5788/","text":"排序是将一组“无序”的记录序列调整为“有序”的记录序列 含有多个域的数据元素称为记录，用于对记录进行唯一标识的域称为关键字 根据在排序过程中涉及的存储器不同，可将排序方法分为两大类：内部排序和外部排序 a. 内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列 b. 外部排序指的是大文件的排序，待排序的文件无法一次装入内存，将待排序的记录存储在外存储器上，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的 排序算法的复杂度 a. 简单的排序方法，时间复杂度为O(n^{2}) b. 先进的排序方法，时间复杂度为O(nlogn) c. 基数排序，时间复杂度为O(n) d. 希尔排序的算法时间复杂度与增量序列有关，还涉及到一些数学上尚未解决的难题，其算法时间复杂度不属于以上类别 排序算法的稳定性 a. 假设ki = kj (1≤i≤n,1≤j≤n,i≠j)，且在排序前的序列中ki领先于kj (即i &lt; j)。若在排序后的序列中ki仍领先于kj，则称所用的排序方法是稳定的；否则，排序方法是不稳定的。 b. 从排序的稳定性上来看，基数排序是稳定的，除了简单选择排序，其他各种简单排序法是稳定的。然而，快速排序、堆排序、希尔排序等时间性能较好的排序方法，以及简单选择排序都是不稳定的。多数情况下，排序是按照记录的主关键字进行的，此时不用考虑排序方法的稳定性。如果排序是按记录的次关键字进行的，则应充分考虑排序方法的稳定性。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://niithub.cn/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"简单选择排序","date":"2019-06-12T13:48:00.000Z","path":"/posts/7c936fca/","text":"程序实现 C 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int KeyType;typedef struct RcdType{ KeyType key; }RecordType, RcdType;void selectSort(RcdType rcd[], int length);int main(int argc, char *argv[]) { RecordType record[9]; int i =1; for (i; i &lt;= 8; i++) { scanf(\"%d\", &amp;record[i]); } selectSort(record, 8); for (i = 1; i &lt;= 8; i++) { printf(\"%d\\n\", record[i]); } return 0;}void selectSort(RcdType rcd[], int length) { int n = length, k, j; RcdType x; for (int i = 1; i &lt; n - 1; ++i) { k = i; for(j = i + 1; j &lt;= n; ++j) { if (rcd[j].key &lt; rcd[k].key) { k = j; } } if (k != i) { x = rcd[i]; rcd[i] = rcd[k]; rcd[k] = x; } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://niithub.cn/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"分治法应用：快速排序算法","date":"2019-06-12T13:07:00.000Z","path":"/posts/792d772/","text":"基本思想 首先从待排序列中选定一个关键字，称之为枢轴 将待排序序列划分成位于枢轴前后的两个子序列 枢轴之前的子序列的所有关键字都不大于枢轴 枢轴之后的子序列的所有关键字都不小于枢轴 此时枢轴已到位，再按同样方法对这两个子序列分别递归进行快速排序，最终使得整个序列有序 程序实现 C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int KeyType;typedef struct RcdType{ KeyType key; }RecordType, RcdType;int Partition(RcdType rcd[ ], int low, int high);void QSort(RcdType rcd[], int s, int t);void QuickSort(RecordType l[]);int main(int argc, char *argv[]) { RecordType record[9]; int i =1; for (i; i &lt;= 8; i++) { scanf(\"%d\", &amp;record[i]); } QuickSort(record); for (i = 1; i &lt;= 8; i++) { printf(\"%d\\n\", record[i]); } return 0;}int Partition(RcdType rcd[ ], int low, int high) { // 对rcd[low..high] 作一次划分，并返回枢轴记录应该所处的位置 rcd[0] = rcd[low]; // 将枢轴移至数组的闲置分量 while(low&lt;high) { // low和high从两端交替地向中间移动 while (low&lt;high &amp;&amp; rcd[high].key &gt;= rcd[0].key) { --high; } // 将比枢轴小的记录移到前端 rcd[low] = rcd[high]; while(low&lt;high &amp;&amp; rcd[low].key &lt;= rcd[0].key) { ++low; } // 将比枢轴大的记录移到后端 rcd[high] = rcd[low]; } rcd[low] = rcd[0]; return low;}void QSort(RcdType rcd[], int s, int t) { // 对记录序列 rcd[s..t] 进行快速排序 if(s &lt; t) { // 长度大于1 // 对rcd[s..t]一趟划分，并返回枢轴位置 int pivotloc = Partition(rcd, s, t); // 对前子序列递归进行排序 QSort(rcd, s, pivotloc-1); // 对后子序列递归进行排序 QSort(rcd, pivotloc+1, t); }}void QuickSort(RcdType l[]) { // 对记录的顺序表 L 进行快速排序 QSort(l, 1, 8);} 笔记 对rcd[low..high] 进行一次划分，并返回枢轴记录应该所处的位置，将位标low指向待排序列的第一个记录，位标high指向最后一个记录，指定low所指的记录为枢轴，将枢轴记录复制至数组的闲置分量，即rcd序列的0号单元rcd[0] 在low &lt; high的前提下，位标low和high从两端交替地向中间移动，并适时将小于枢轴的记录向前移动，将大于枢轴的记录向后移动。由于实际上low所指的单元已经闲置，所以应当从high开始向前搜索比枢轴小的记录，找到后就将其移动至low所指的闲置单元 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://niithub.cn/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"算法训练-按位打印数据","date":"2019-05-30T13:47:00.000Z","path":"/posts/cd24fead/","text":"问题描述编写程序，实现从键盘输入一个正整数，输出该正整数的位数及每位数 输出样例1234 输出样例第1位是1 第2位是2 第3位是3 第4位是4 共有4位 解题思路使用队列接收所有的字符，并记录队列的入队数，而后字符出队，打印字符 程序实现 C1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Queue { int data; struct Queue *next;} Queue;typedef struct LinkQueue { Queue *front; Queue *rear;} LinkQueue;int initQueue(LinkQueue *linkQueue);int enterQueue(LinkQueue *linkQueue, char number);char outQueue(LinkQueue *linkQueue);/** * 使用队列存储得到的每一位字符 * 记录输入的字符数 * 出队打印队列中的数据 */int main(int argc, char *argv[]) { LinkQueue link; initQueue(&amp;link); char number; number = getchar(); int i = 0; while (number != '\\n') { enterQueue(&amp;link, number); i++; number = getchar(); } for (int j = 1; j &lt;= i; j++) { printf(\"第%d位是:%c\\n\", j, outQueue(&amp;link)); } printf(\"共有%d位\", i); return 0;}/** * 初始化队列 */int initQueue(LinkQueue *linkQueue) { linkQueue-&gt;front = (Queue*)malloc(sizeof(Queue)); if (linkQueue-&gt;front != NULL) { linkQueue-&gt;rear = linkQueue-&gt;front; linkQueue-&gt;front-&gt;next = NULL; return 1; } else { return 0; }}/** * 入队操作 * linkQueue：队列 * number：输入的字符 */int enterQueue(LinkQueue *linkQueue, char number) { Queue *q = (Queue *)malloc(sizeof(Queue)); if (q != NULL) { q-&gt;data = number; q-&gt;next = NULL; linkQueue-&gt;rear-&gt;next = q; linkQueue-&gt;rear = q; } else { return 0; } return 1;}/** * 出队操作 * linkQueue：队列 * return：出队的字符 */char outQueue(LinkQueue *linkQueue) { char number; Queue *q; if (linkQueue-&gt;front == linkQueue-&gt;rear) { return 0; } q = linkQueue-&gt;front-&gt;next; linkQueue-&gt;front-&gt;next = q-&gt;next; if (linkQueue-&gt;rear == q) { linkQueue-&gt;rear = linkQueue-&gt;front; } number = q-&gt;data; free(q); return number; } 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"https://niithub.cn/tags/%E9%98%9F%E5%88%97/"}]},{"title":"CentOS自建Anki服务器","date":"2019-05-27T00:42:00.000Z","path":"/posts/d855f5cd/","text":"服务器配置CentOS 7.4 x64系统 安装AnkiServer包 安装pip12curl https://bootstrap.pypa.io/get-pip.py -o get-pip.pypython get-pip.py pip安装AnkiServer1pip install AnkiServer 设置AnkiServer 创建anki文件夹 1mkdir anki 复制example.ini文件 找到AnkiServer中示例配置的目录，我的在/usr/lib/python2.7/site-packages/AnkiServer-2.0.6-py2.7.egg/examples 1cp /usr/lib/python2.7/site-packages/AnkiServer-2.0.6-py2.7.egg/examples/example.ini ~/Anki/production.ini 修改production.ini文件 1vi production.ini host位置填写服务器内网地址，port位置填写你要开放的端口号 用户管理 新增用户 1ankiserverctl.py adduser &lt;username&gt; 之后会要求你输入新增用户的密码 查看新增用户 1ankiserverctl.py lsuser 调试模式运行 1ankiserverctl.py debug 调试成功，关闭调试模式，后台运行ankiServer 后台运行ankiServer 1ankiserverctl.py start &amp; Windows客户端版Anki的设置 打开插件文件夹 新建配置文件 新建mysyncserver.py 配置服务器信息 123 import anki.syncanki.sync.SYNC_BASE = 'http://ip:27701/'anki.sync.SYNC_MEDIA_BASE = 'http://ip:27701/msync/' 重启anki 点击同步按钮，输入自己在服务器里设置的用户名和密码，体验自有服务器上的anki同步服务 安卓端Anki设置 打开设置 配置高级设置 配置自有服务器地址 同步地址及媒体文件同步地址请参考上文windows客户端下的配置文件 完结撒花成功搭建了自己的Anki同步服务器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"线性表顺序存储-练习题1","date":"2019-05-20T05:53:00.000Z","path":"/posts/794029a6/","text":"问题描述已知顺序表L递增有序，试写一算法，将X插入到线性表的适当位置，以保持线性表的有序性。 解题思路从右往左遍历顺序表，如果i不大于X，则右移一位，直到结束。 程序实现 C1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 101typedef struct { int r[MAXSIZE]; int length;} SqList;int main(int argc, char *argv[]) { SqList list; int i, x = 1;; list.length = 5; for (i = 0; i &lt; list.length; i++) { list.r[i] = i * 3; } printf(\"初始顺序表：\\n\"); for (i = 0; i &lt; list.length; i++) { printf(\"%d\\t\", list.r[i]); } printf(\"\\n\"); if (list.length + 1 &gt; MAXSIZE) { printf(\"数组溢出!\"); return 0; } for (i = list.length; list.r[i] &gt; x &amp;&amp; i &gt; -1; i--) { list.r[i + 1] = list.r[i]; } list.r[++i] = x; list.length++; printf(\"插入X后的顺序表：\\n\"); for (i = 0; i &lt; list.length; i++) { printf(\"%d\\t\", list.r[i]); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性表","slug":"线性表","permalink":"https://niithub.cn/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"线性表顺序存储-练习题2","date":"2019-05-20T05:51:00.000Z","path":"/posts/e049781c/","text":"问题描述写一算法，从顺序表中删除自第i个元素开始的K个元素。 解题思路需要注意起始位置i与K的关系，如果之和大于等于顺序表的长度，则直接修改顺序表的长度即可，否则需以K为步伐间距移动顺序表中元素的位置。 程序实现 C12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 101#define TRUE 1#define FALSE 0typedef struct { int r[MAXSIZE]; int length;} SqList;int deleteElement(SqList *L, int start, int number);void print(SqList L);int main(int argc, char *argv[]) { SqList list; int i; list.length = 9; for (i = 1; i &lt;= list.length; i++) { list.r[i] = i * 3; } printf(\"初始顺序表：\\n\"); print(list); printf(\"\\n\"); if (!deleteElement(&amp;list, 3, 6)) { printf(\"删除失败\"); return -1; } else { printf(\"删除成功\"); } printf(\"\\n删除后的顺序表：\\n\"); print(list); return 0;}/** * 删除自第i个元素开始的k个元素 * start: 开始的第i个元素位置 * number: 要删除的元素个数 */int deleteElement(SqList *L, int start, int number) { int i; if (start &lt; 1 || number &lt; 0) { return FALSE; } if (start + number &gt; L-&gt;length) { L-&gt;length = start; } else { for (i = start; i &lt; L-&gt;length; i++) { L-&gt;r[i] = L-&gt;r[i + number]; } L-&gt;length -= number; } return TRUE;}void print(SqList L) { for (int i = 1; i &lt;= L.length; i++) { printf(\"%d\\t\", L.r[i]); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性表","slug":"线性表","permalink":"https://niithub.cn/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"线性表的顺序存储实现","date":"2019-05-20T05:49:00.000Z","path":"/posts/55ddc25b/","text":"基础操作 C 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 初始化顺序表 */void initList(SqList *L) { L-&gt;length=0;}/** * 销毁顺序表 */void destroyList(SqList *L) { L-&gt;length = -1;}/** * 置空顺序表 */void clearList(SqList *L) { L-&gt;length = 0;}/** * 如果顺序表为空表，则返回真，否则返回假 */int emptyList(SqList *L) { if (0 == L-&gt;length) { return OK; } else { return FALSE; }}/** * L存在，且i值合法，即1 &lt;= i &lt;= length, 则返回第i个元素的值 */int getList(SqList *L, int i) { if (L-&gt;length &lt;= 0 || i &gt; L-&gt;length) { return FALSE; } return L-&gt;r[i];} 插入操作 线性表的插入运算是指在表的第i个位置，插入一个新元素e，使长度为n的线性表变成长度为n + 1的线性表。 C12345678910111213141516171819202122/** * 表L存在，e为合法元素值，且1 &lt;= i &lt;= length + 1 * 在表L中第i个位置插入新的元素e，L的长度加1 * 注意：本例子中，默认从下标1开始，如顺序表[0,1]的长度为1 */int insList(SqList *L, int i, int e) { int j; if (L-&gt;length == MAXSIZE) { return FALSE; } if (i &lt;= 0 || i &gt; L-&gt;length + 1) { return FALSE; } if (i &lt;= L-&gt;length) { for (j = L-&gt;length + 1; j &gt;= i ; j--) { L-&gt;r[j + 1] = L-&gt;r[j]; } } L-&gt;r[i] = e; L-&gt;length++; return OK;} 删除操作线性表的删除操作时指将表的第i个元素删去，使长度为n的线性表变成长度为n-1的线性表。 C123456789101112131415/** * 表L存在且非空，1 &lt;= i &lt;= length * 删除L的第i个数据元素，并用e返回其值，L的长度减1 */void delList(SqList *L, int i, int *e) { int j; *e = L-&gt;r[i]; if (i &lt; L-&gt;length) { for (j = i; j &lt;= L-&gt;length; j++) { L-&gt;r[j] = L-&gt;r[j + 1]; } } L-&gt;length--;} 合并操作 两个有序线性表，使新线性表也有序 方法一：从线性表尾开始比较，指到其中一个线性表的表长为0，然后将另一线性表的剩余元素移动到新线性表上 C12345678910111213141516171819202122232425262728293031/** * 合并LA、LB两个顺序表 */int unionList(SqList *L, SqList *LA, SqList *LB) { if (LA-&gt;length + LB-&gt;length &gt; MAXSIZE) { return FALSE; } L-&gt;length = LA-&gt;length + LB-&gt;length; int i; for (i = LA-&gt;length + LB-&gt;length; LA-&gt;length &gt; 0 &amp;&amp; LB-&gt;length &gt; 0; i--) { if (LA-&gt;r[LA-&gt;length] &gt;= LB-&gt;r[LB-&gt;length]) { L-&gt;r[i] = LA-&gt;r[LA-&gt;length]; LA-&gt;length--; } else { L-&gt;r[i] = LB-&gt;r[LB-&gt;length]; LB-&gt;length--; } } if (LA-&gt;length &gt; 0) { for (i; i &gt; 0; i--) { L-&gt;r[i] = LA-&gt;r[LA-&gt;length]; LA-&gt;length--; } } else { for (i; i &gt; 0; i--) { L-&gt;r[i] = LB-&gt;r[LB-&gt;length]; LB-&gt;length--; } } return OK;} 方法二：设两个指针i,j,k分别指向待合并的线性表LA、LB、新线性表，如果LA-&gt;r[i] &gt;= LB-&gt;r[j]，则将LA-&gt;r[i]插入到新线性表中，i++,k++；否则反之,j++,k++。 C1234567891011121314151617181920212223242526272829303132/** * 合并LA、LB两个顺序表 */int unionList2(SqList *L, SqList *LA, SqList *LB) { if (LA-&gt;length + LB-&gt;length &gt; MAXSIZE) { return FALSE; } int i = 1, j = 1, k = 1, n; L-&gt;length = LA-&gt;length + LB-&gt;length; while (i &lt;= LA-&gt;length &amp;&amp; j &lt;= LB-&gt;length) { if (LA-&gt;r[i] &gt;= LB-&gt;r[j]) { L-&gt;r[k] = LA-&gt;r[i]; i++; k++; } else { L-&gt;r[k] = LB-&gt;r[j]; j++; k++; } } while (i &lt;= LA-&gt;length) { L-&gt;r[k] = LA-&gt;r[i]; i++; k++; } while (i &lt;= LB-&gt;length) { L-&gt;r[k] = LB-&gt;r[j]; j++; k++; } return OK;} 完整实例： C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 101#define OK 1#define FALSE 0typedef struct { int r[MAXSIZE]; int length;} SqList;void print(SqList L);void initList(SqList *L);void destroyList(SqList *L);void clearList(SqList *L);int emptyList(SqList *L);int locateList(SqList *L, int e);int getList(SqList *L, int e);int insList(SqList *L, int i, int e);void delList(SqList *L, int i, int *e);int unionList(SqList *L, SqList *LA, SqList *LB);int unionList2(SqList *L, SqList *LA, SqList *LB);int main(int argc, char *argv[]) { SqList list, list1, list2; int result, deleteNum; printf(\"初始化顺序表:\\n\"); initList(&amp;list); initList(&amp;list1); printf(\"长度为：%d\\n\", list.length); for (int i = 1; i &lt;= 6; i++) { list.r[i] = i * 3; list.length++; } for (int i = 1; i &lt;= 4; i++) { list1.r[i] = i * 2; list1.length++; } printf(\"顺序表的内容:\\n\"); print(list); if (insList(&amp;list, 6, 2)) { printf(\"插入成功\\n\"); printf(\"插入元素后的顺序表的内容:\\n\"); print(list); } else { printf(\"插入失败\\n\"); } delList(&amp;list, 6, &amp;deleteNum); printf(\"删除的数字是:%d\\n\", deleteNum); printf(\"删除后的顺序表的内容:\\n\"); print(list); printf(\"顺序表LB的内容:\\n\"); print(list1); printf(\"顺序表合并后的内容:\\n\"); unionList(&amp;list2, &amp;list, &amp;list1); print(list2); destroyList(&amp;list); return 0;}/** * 打印函数 */void print(SqList L) { for (int i = 1; i &lt;= L.length; i++) { printf(\"%d\\t\", L.r[i]); } printf(\"\\n\");}/** * 初始化顺序表 */void initList(SqList *L) { L-&gt;length=0;}/** * 销毁顺序表 */void destroyList(SqList *L) { L-&gt;length = -1;}/** * 置空顺序表 */void clearList(SqList *L) { L-&gt;length = 0;}/** * 如果顺序表为空表，则返回真，否则返回假 */int emptyList(SqList *L) { if (0 == L-&gt;length) { return OK; } else { return FALSE; }}/** * L存在，且i值合法，即1 &lt;= i &lt;= length, 则返回第i个元素的值 */int getList(SqList *L, int i) { if (L-&gt;length &lt;= 0 || i &gt; L-&gt;length) { return FALSE; } return L-&gt;r[i];}/** * 表L存在，e为合法元素值，且1 &lt;= i &lt;= length + 1 * 在表L中第i个位置插入新的元素e，L的长度加1 * 注意：本例子中，默认从下标1开始，如顺序表[0,1]的长度为1 */int insList(SqList *L, int i, int e) { int j; if (L-&gt;length == MAXSIZE) { return FALSE; } if (i &lt;= 0 || i &gt; L-&gt;length + 1) { return FALSE; } if (i &lt;= L-&gt;length) { for (j = L-&gt;length + 1; j &gt;= i ; j--) { L-&gt;r[j + 1] = L-&gt;r[j]; } } L-&gt;r[i] = e; L-&gt;length++; return OK;}/** * 表L存在且非空，1 &lt;= i &lt;= length * 删除L的第i个数据元素，并用e返回其值，L的长度减1 */void delList(SqList *L, int i, int *e) { int j; *e = L-&gt;r[i]; if (i &lt; L-&gt;length) { for (j = i; j &lt;= L-&gt;length; j++) { L-&gt;r[j] = L-&gt;r[j + 1]; } } L-&gt;length--;}/** * 合并LA、LB两个顺序表 */int unionList(SqList *L, SqList *LA, SqList *LB) { if (LA-&gt;length + LB-&gt;length &gt; MAXSIZE) { return FALSE; } L-&gt;length = LA-&gt;length + LB-&gt;length; int i; for (i = LA-&gt;length + LB-&gt;length; LA-&gt;length &gt; 0 &amp;&amp; LB-&gt;length &gt; 0; i--) { if (LA-&gt;r[LA-&gt;length] &gt;= LB-&gt;r[LB-&gt;length]) { L-&gt;r[i] = LA-&gt;r[LA-&gt;length]; LA-&gt;length--; } else { L-&gt;r[i] = LB-&gt;r[LB-&gt;length]; LB-&gt;length--; } } if (LA-&gt;length &gt; 0) { for (i; i &gt; 0; i--) { L-&gt;r[i] = LA-&gt;r[LA-&gt;length]; LA-&gt;length--; } } else { for (i; i &gt; 0; i--) { L-&gt;r[i] = LB-&gt;r[LB-&gt;length]; LB-&gt;length--; } } return OK;}/** * 合并LA、LB两个顺序表 */int unionList2(SqList *L, SqList *LA, SqList *LB) { if (LA-&gt;length + LB-&gt;length &gt; MAXSIZE) { return FALSE; } int i = 1, j = 1, k = 1, n; L-&gt;length = LA-&gt;length + LB-&gt;length; while (i &lt;= LA-&gt;length &amp;&amp; j &lt;= LB-&gt;length) { if (LA-&gt;r[i] &gt;= LB-&gt;r[j]) { L-&gt;r[k] = LA-&gt;r[i]; i++; k++; } else { L-&gt;r[k] = LB-&gt;r[j]; j++; k++; } } while (i &lt;= LA-&gt;length) { L-&gt;r[k] = LA-&gt;r[i]; i++; k++; } while (i &lt;= LB-&gt;length) { L-&gt;r[k] = LB-&gt;r[j]; j++; k++; } return OK;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"线性表","slug":"线性表","permalink":"https://niithub.cn/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"顺序","slug":"顺序","permalink":"https://niithub.cn/tags/%E9%A1%BA%E5%BA%8F/"}]},{"title":"线性表的链式存储实现","date":"2019-05-20T05:46:00.000Z","path":"/posts/94e0fe2a/","text":"基础操作 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 遍历输出单链表 */void print(LinkList H) { LinkList p = H-&gt;next; while (p) { printf(\"%c\", p-&gt;data); p = p-&gt;next; }}/** * 初始化链表 */void initList(LinkList *H) { /* 产生头结点,并使L指向此头结点 */ *H = (LinkList)malloc(sizeof (List)); (* H)-&gt;next = NULL;}/** * 初始条件：顺序线性表L已存在。 * 操作结果：若L为空表，则返回TRUE，否则返回FALSE */int listEmpty(LinkList L) { if(L-&gt;next) { return ERROR; } else { return OK; }}/** * 初始条件：顺序线性表L已存在。 * 操作结果：将L重置为空表 */int clearList(LinkList *L) { LinkList p,q; p = (*L)-&gt;next; /* p指向第一个结点 */ while(p) { /* 没到表尾 */ q = p-&gt;next; free(p); p = q; } (*L)-&gt;next = NULL; /* 头结点指针域为空 */ return OK;}/** * 初始条件：顺序线性表L已存在。 * 操作结果：返回L中数据元素个数 */int listLength(LinkList L) { int i = 0; LinkList p = L-&gt;next; /* p指向第一个结点 */ while(p) { i++; p = p-&gt;next; } return i;} 以头插法建立单链表 C 1234567891011121314151617181920/** * 以头插法建立单链表 * 以\"#\"符为结束符 */void createFromHead(LinkList H) { List *node; ElementType type; int flag = 1; while (flag) { type = getchar(); if ('#' != type) { node = (List *)malloc(sizeof(List)); node-&gt;data = type; node-&gt;next = H-&gt;next; H-&gt;next = node; } else { flag = 0; } }} 以尾插法建立单链表 C 123456789101112131415161718192021/** * 以尾插法建立单链表 * 以\"#\"符为结束符 */void createFromEnd(LinkList H) { List *node; ElementType type; int flag = 1; while(flag) { type = getchar(); if ('#' != type ) { node = (List *)malloc(sizeof(List)); node-&gt;data = type; H-&gt;next = node; H = node; } else { flag = 0; H-&gt;next = NULL; } }} 在单链表L中查找第i个结点 C123456789101112/** * 在单链表L中查找第i个结点 */List *get(LinkList L, int i) { List *list = L-&gt;next; int index = 1; while (index != i &amp;&amp; list-&gt;next != NULL) { index++; list = list-&gt;next; } return list;} 在单链表L中查找值等于key的个结点 C12345678910/** * 在单链表L中查找值等于key的个结点 */List *locate(LinkList L, ElementType key) { List *list = L-&gt;next; while (list-&gt;data != key &amp;&amp; list-&gt;next != NULL) { list = list-&gt;next; } return list;} 在单链表的第i位插入元素e C1234567891011121314151617181920212223/** * 在单链表的第i位插入元素e */int insertList(LinkList L, int i, ElementType e) { List *list = L, *p; int index = 0; while (index &lt; i - 1 &amp;&amp; list-&gt;next != NULL) { index++; list = list-&gt;next; } /** * 跳出循环是因为list在链表最后或i&lt;1，所以一定是插入位置不合法 */ if (index != i -1) { printf(\"插入位置不合法！\"); return ERROR; } p = (List *)malloc(sizeof(List)); p-&gt;data = e; p-&gt;next = list-&gt;next; list-&gt;next = p; return OK;} 删除单链表的第i位元素 C123456789101112131415161718192021222324/** * 删除单链表的第i位元素,并将删除的元素保存至元素e中 */int deleteList(LinkList L, int i, ElementType *e) { List *list = L, *p; int index = 0; while (index &lt; i - 1 &amp;&amp; list-&gt;next != NULL) { index++; list = list-&gt;next; } /** * 跳出循环是因为list在链表最后或i&lt;1，所以一定是位置不合法 */ if (index != i -1) { printf(\"位置不合法！\"); return ERROR; } p = list-&gt;next; *e = p-&gt;data; list-&gt;next = p-&gt;next; /*一定要记得释放删除的结点所占内存空间*/ free(p); return OK;} 完整实例 C123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define OK 1#define ERROR 0typedef char ElementType;typedef struct Node { ElementType data; struct Node * next;} List, *LinkList;void print(LinkList H);void initList(LinkList *H);int listEmpty(LinkList L);int clearList(LinkList *L);int listLength(LinkList L);void createFromHead(LinkList H);void createFromEnd(LinkList H);List *get(LinkList L, int i);List *locate(LinkList L, ElementType key);int insertList(LinkList L, int i, ElementType e);int deleteList(LinkList L, int i, ElementType *e);int main(int argc, char *argv[]) { LinkList H; initList(&amp;H); printf(\"头插法实现链表：\\n\"); createFromHead(H); printf(\"头插法结果：\\n\"); print(H); List *result = get(H, 3); printf(\"\\n查找第3位元素，结果：%c\\n\", result-&gt;data); printf(\"\\n尾插法实现链表：\\n\"); createFromEnd(H); printf(\"尾插法结果：\\n\"); print(H); printf(\"\\n往链表的第3位插入元素F：\\n\"); char element = 'F'; insertList(H, 3, element); printf(\"插入结果：\\n\"); print(H); char e; deleteList(H, 4, &amp;e); printf(\"\\n删除链表的第4位元素：%c\\n\", e); print(H); int i = clearList(&amp;H); printf(\"\\n遍历清空后的链表：\\n\"); print(H); printf(\"链表的长度length(H) = %d\\n\", listLength(H)); return 0;}/** * 遍历输出单链表 */void print(LinkList H) { LinkList p = H-&gt;next; while (p) { printf(\"%c\", p-&gt;data); p = p-&gt;next; }}/** * 初始化链表 */void initList(LinkList *H) { /* 产生头结点,并使L指向此头结点 */ *H = (LinkList)malloc(sizeof (List)); (* H)-&gt;next = NULL;}/** * 初始条件：顺序线性表L已存在。 * 操作结果：若L为空表，则返回TRUE，否则返回FALSE */int listEmpty(LinkList L) { if(L-&gt;next) { return ERROR; } else { return OK; }}/** * 初始条件：顺序线性表L已存在。 * 操作结果：将L重置为空表 */int clearList(LinkList *L) { LinkList p,q; p = (*L)-&gt;next; /* p指向第一个结点 */ while(p) { /* 没到表尾 */ q = p-&gt;next; free(p); p = q; } (*L)-&gt;next = NULL; /* 头结点指针域为空 */ return OK;}/** * 初始条件：顺序线性表L已存在。 * 操作结果：返回L中数据元素个数 */int listLength(LinkList L) { int i = 0; LinkList p = L-&gt;next; /* p指向第一个结点 */ while(p) { i++; p = p-&gt;next; } return i;}/** * 以头插法建立单链表 * 以\"#\"符为结束符 */void createFromHead(LinkList H) { List *node; ElementType type; int flag = 1; while (flag) { type = getchar(); if ('#' != type) { node = (List *)malloc(sizeof(List)); node-&gt;data = type; node-&gt;next = H-&gt;next; H-&gt;next = node; } else { flag = 0; } }}/** * 以尾插法建立单链表 * 以\"#\"符为结束符 */void createFromEnd(LinkList H) { List *node; ElementType type; int flag = 1; while(flag) { type = getchar(); if ('#' != type ) { node = (List *)malloc(sizeof(List)); node-&gt;data = type; H-&gt;next = node; H = node; } else { flag = 0; H-&gt;next = NULL; } }}/** * 在单链表L中查找第i个结点 */List *get(LinkList L, int i) { List *list = L-&gt;next; int index = 1; while (index != i &amp;&amp; list-&gt;next != NULL) { index++; list = list-&gt;next; } return list;}/** * 在单链表L中查找值等于key的个结点 */List *locate(LinkList L, ElementType key) { List *list = L-&gt;next; while (list-&gt;data != key &amp;&amp; list-&gt;next != NULL) { list = list-&gt;next; } return list;}/** * 在单链表的第i位插入元素e */int insertList(LinkList L, int i, ElementType e) { List *list = L, *p; int index = 0; while (index &lt; i - 1 &amp;&amp; list-&gt;next != NULL) { index++; list = list-&gt;next; } /** * 跳出循环是因为list在链表最后或i&lt;1，所以一定是插入位置不合法 */ if (index != i -1) { printf(\"插入位置不合法！\"); return ERROR; } p = (List *)malloc(sizeof(List)); p-&gt;data = e; p-&gt;next = list-&gt;next; list-&gt;next = p; return OK;}/** * 删除单链表的第i位元素,并将删除的元素保存至元素e中 */int deleteList(LinkList L, int i, ElementType *e) { List *list = L, *p; int index = 0; while (index &lt; i - 1 &amp;&amp; list-&gt;next != NULL) { index++; list = list-&gt;next; } /** * 跳出循环是因为list在链表最后或i&lt;1，所以一定是位置不合法 */ if (index != i -1) { printf(\"位置不合法！\"); return ERROR; } p = list-&gt;next; *e = p-&gt;data; list-&gt;next = p-&gt;next; /*一定要记得释放删除的结点所占内存空间*/ free(p); return OK;} 总结 一定要理清结点之间的关系 删除结点后要注意释放内存空间 插入结点或new 结点后，需要申请内存空间 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"线性表","slug":"线性表","permalink":"https://niithub.cn/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"链式","slug":"链式","permalink":"https://niithub.cn/tags/%E9%93%BE%E5%BC%8F/"}]},{"title":"线性表链式存储-练习题1","date":"2019-05-20T05:45:00.000Z","path":"/posts/f95d370c/","text":"问题描述写一算法，从链式表中删除自第i个元素开始的K个元素。 解题思路需要注意删除结点后，一定要释放内存空间。 程序实现 C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define OK 1#define ERROR 0typedef int ElementType;typedef struct Node { ElementType data; struct Node * next;} List, *LinkList;void print(LinkList H);void initList(LinkList *H);void createFromEnd(LinkList H);int deleteList(LinkList L, int i, int k);int main(int argc, char *argv[]) { LinkList H; initList(&amp;H); printf(\"尾插法实现链表：\\n\"); createFromEnd(H); printf(\"尾插法结果：\\n\"); print(H); deleteList(H, 1, 9); printf(\"\\n删除链表部分元素后：\\n\"); print(H); return 0;}/** * 遍历输出单链表 */void print(LinkList H) { LinkList p = H-&gt;next; while (p) { printf(\"%d\\t\", p-&gt;data); p = p-&gt;next; }}/** * 初始化链表 */void initList(LinkList *H) { /* 产生头结点,并使L指向此头结点 */ *H = (LinkList)malloc(sizeof (List)); (* H)-&gt;next = NULL;}/** * 以尾插法建立单链表 */void createFromEnd(LinkList H) { List *node; ElementType type; srand(time(0)); int i = 0; for (i; i &lt; 10; i++) { node = (List *)malloc(sizeof(List)); node-&gt;data = rand() % 100 + 1; H-&gt;next = node; H = node; } H-&gt;next = NULL;}/** * 删除单链表中自第i位元素开始的k个元素 */int deleteList(LinkList L, int i, int k) { List *list = L, *p; int index = 0; while (index &lt; i - 1 &amp;&amp; list-&gt;next != NULL) { index++; list = list-&gt;next; } if (index != i -1) { printf(\"\\n插入位置不合法！\\n\"); return ERROR; } for (index = 0; index &lt; k &amp;&amp; list-&gt;next != NULL; index++) { p = list-&gt;next; list-&gt;next = p-&gt;next; /*一定要记得释放删除的结点所占内存空间*/ free(p); } return OK;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性表","slug":"线性表","permalink":"https://niithub.cn/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"线性表顺序存储-练习题3-逆置顺序表","date":"2019-05-20T05:41:00.000Z","path":"/posts/4f293ae6/","text":"问题描述以顺序表作存储结构实现线性表，实现就地逆置算法，即在原表的存储空间将线性表(a1, a2, …, an)逆置为(an, … , a2, a1). 解题思路 需要考虑的线性表个数的奇/偶数情况，奇/偶数情况不同，置换的步伐长度不同 设置一个中转数，当做数置换时做中转存储 程序实现 C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 101typedef struct { int r[MAXSIZE]; int length;} SqList;void inverseElement(SqList *L);void print(SqList L);int main(int argc, char *argv[]) { SqList list; int i; list.length = 9; for (i = 1; i &lt;= list.length; i++) { list.r[i] = i * 3; } printf(\"初始顺序表：\\n\"); print(list); printf(\"\\n\"); inverseElement(&amp;list); printf(\"置换后的顺序表：\\n\"); print(list); return 0;}/** * 逆置顺序表 */void inverseElement(SqList *L) { int middle = 0, k = -1, i; if (L-&gt;length % 2 == 0) { for (i = L-&gt;length / 2; i &gt; 0; i--) { k += 2; middle = L-&gt;r[i]; L-&gt;r[i] = L-&gt;r[i + k]; L-&gt;r[i + k] = middle; } } else { k = 0; for (i = L-&gt;length / 2; i &gt; 0; i--) { k += 2; middle = L-&gt;r[i]; L-&gt;r[i] = L-&gt;r[i + k]; L-&gt;r[i + k] = middle; } }}void print(SqList L) { for (int i = 1; i &lt;= L.length; i++) { printf(\"%d\\t\", L.r[i]); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"线性表","slug":"线性表","permalink":"https://niithub.cn/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"队列的简单实现","date":"2019-05-20T05:40:00.000Z","path":"/posts/6a4f6c6e/","text":"队列特点： 先进先出 程序实现： C 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 101typedef struct { /*队列的主体内容，用来存储内容*/ int data[MAXSIZE]; /*队首*/ int head; /*队尾*/ int tail; }Queue;int main(int argc, char *argv[]) { Queue q; int i; q.head = 1; q.tail = 1; for (i = 1; i &lt; 10; i++) { scanf(\"%d\", &amp;q.data[q.tail]); q.tail++; } while (q.head &lt; q.tail) { printf(\"%d\\t\", q.data[q.head]); q.head++; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"队列","slug":"队列","permalink":"https://niithub.cn/tags/%E9%98%9F%E5%88%97/"}]},{"title":"循环单向链表-合并算法","date":"2019-05-20T05:38:00.000Z","path":"/posts/9579ad62/","text":"基础知识循环链表是单链表的另一种形式，它是一个首尾相接的链表，其特点是将单链表最后一个结点的指针域由NULL改为指向头结点或线性表中的第一个结点，就得到了单链形式的循环链表，并称为循环单链表。 循环链表的图解 合并思路先找到两个链表的尾，并分别由指针p、q指向他们，然后将第一个链表的尾与第二个链表的第一个结点链接起来，并修改第二个表的尾Q，使它的链域指向第一个表的头结点。 注意：链表合并后，需记得释放被合并链表的头结点。 程序实现 C 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node { int data; struct Node * next;} Node, *LinkList;void initLink(LinkList *link);void create(LinkList link, int start);void fusion(LinkList linkA, LinkList linkB);int main(int argc, char *argv[]) { LinkList LinkA, LinkB; initLink(&amp;LinkA); initLink(&amp;LinkB); create(LinkA, 1); create(LinkB, 10); fusion(LinkA, LinkB); Node *p; p = LinkA-&gt;next; while (p != LinkA) { printf(\"%d\\n\", p-&gt;data); p = p-&gt;next; } return 0;}/** * 初始化链表 */void initLink(LinkList *link) { *link = (LinkList)malloc(sizeof(Node)); (*link)-&gt;next = NULL;}/** * 创建循环链表 */void create(LinkList link, int start) { Node *node, *q; q = link; int i; for (i = start; i &lt; start + 5; i++) { node = (Node *)malloc(sizeof(Node)); node-&gt;data = i; link-&gt;next = node; link = node; } link-&gt;next = q;}/*** * 合并循环链表 */void fusion(LinkList linkA, LinkList linkB) { Node *p, *q; p = linkA-&gt;next; q = linkB-&gt;next; while (p-&gt;next != linkA) { p = p-&gt;next; } while (q-&gt;next != linkB) { q = q-&gt;next; } p-&gt;next = linkB-&gt;next; q-&gt;next = linkA; /*释放LinkB的头结点*/ free(linkB);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"链表","slug":"链表","permalink":"https://niithub.cn/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"双向链表","date":"2019-05-20T05:36:00.000Z","path":"/posts/37fd9ed5/","text":"基础知识双向链表也叫双链表（Double Linked List），是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 双向循环链表的图解 注意点 在双向链表中，那些只涉及后继指针的算法，如求表长度、取元素、元素定位等，与单链表中相应的算法相同，但对于前插和删除操作则涉及到前驱和后继两个方向的指针变化，因此与单链表中的算法不同。 在插入和删除时，应注意头、尾指针指向的顺序，以免造成迷失要操作的结点地址。 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node { struct Node *prior, *next; int data;} Node, *LinkList;void initLink(LinkList *link);void normalInsert(LinkList link, int size);void print(LinkList link);void positionInsertFromBefore(LinkList link, Node *node, int location);void positionInsertFromEnd(LinkList link, Node *p, int location);int deleteNode(LinkList link, int location);int main(int argc, char *argv[]) { LinkList link; initLink(&amp;link); normalInsert(link, 5); print(link); Node *p; p = (Node *)malloc(sizeof(Node)); p-&gt;data = 9; printf(\"\\n使用前插法往原双向链表插入一个新结点：\\n\"); positionInsertFromBefore(link, p, 3); print(link); printf(\"\\n使用尾插法往原双向链表插入一个新结点：\\n\"); p = (Node *)malloc(sizeof(Node)); p-&gt;data = 8; positionInsertFromEnd(link, p, 3); print(link); printf(\"\\n删除一个结点，结点值为%d：\\n\", deleteNode(link, 3)); print(link); return 0;}void initLink(LinkList *link) { *link = (LinkList)malloc(sizeof(Node)); (*link)-&gt;next = NULL; (*link)-&gt;prior = NULL;}/** * 普通插入，以尾插法插入 * link: 双向链表 * size: 欲插入的结点个数 */void normalInsert(LinkList link, int size) { Node *node; int i; for (i = 1; i &lt;= size; i++) { node = (Node *)malloc(sizeof(Node)); node-&gt;data = i; link-&gt;next = node; node-&gt;prior = link; link = node; } link-&gt;next = NULL;}/** * 打印双向链表 */void print(LinkList link) { Node *node = link-&gt;next, *p; p = (Node *)malloc(sizeof(Node)); printf(\"从前往后打印：\\n\"); while (node) { printf(\"%d\\t\", node-&gt;data); if (node-&gt;next == NULL) { p = node; } node = node-&gt;next; } printf(\"\\n从后往前打印：\\n\"); while (p-&gt;prior) { printf(\"%d\\t\", p-&gt;data); p = p-&gt;prior; }}/** * 双向链表的前插操作，即在双向链表的第i个结点之前插入一个新的结点 * link: 双向链表 * node: 新结点 * location: 欲执行插入操作的位置 */void positionInsertFromBefore(LinkList link, Node *p, int location) { Node *node = link-&gt;next; int i = 1; while (node) { i++; if (location == i) { break; } node = node-&gt;next; } p-&gt;next = node-&gt;next; node-&gt;next-&gt;prior = p; p-&gt;prior = node; node-&gt;next = p;}/** * 双向链表的尾插操作，即在双向链表的第i个结点之后插入一个新的结点 * link: 双向链表 * node: 新结点 * location: 欲执行插入操作的位置 */void positionInsertFromEnd(LinkList link, Node *p, int location) { Node *node = link-&gt;next; int i = 1; while (node) { i++; node = node-&gt;next; if (location == i) { break; } } p-&gt;next = node-&gt;next; node-&gt;next-&gt;prior = p; p-&gt;prior = node; node-&gt;next = p;}/** * 双向链表的删除操作，即删除指定位置的第i个结点 * link: 双向链表 * location: 欲执行删除操作的位置 */int deleteNode(LinkList link, int location) { Node *node = link-&gt;next, *p; int i = 1, result = 0; while (node) { i++; node = node-&gt;next; if (location == i) { break; } } result = node-&gt;data; node-&gt;prior-&gt;next = node-&gt;next; node-&gt;next-&gt;prior = node-&gt;prior; free(node); return result;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"双向链表","slug":"双向链表","permalink":"https://niithub.cn/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"}]},{"title":"链表练习题3-城市查找问题","date":"2019-05-20T05:34:00.000Z","path":"/posts/83dfc713/","text":"问题描述将若干城市的信息存入一个带头结点的单链表，结点中的城市信息包括城市名、城市的位置坐标。要求： 给定一个城市名，返回其位置坐标； 给定一个位置坐标P和一个距离D，返回所有与P的距离小于等于D的城市。本题只考察链表信息，城市名可使用单字符。 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;typedef struct Node { char name; int x; int y; struct Node *next;} Node, *LinkList;void initLink(LinkList *link);void input(LinkList link);void print(LinkList link);void searchByName(LinkList link, char name); void findAllCity(LinkList link, int x, int y, int distance); int main(int argc, char *argv[]) { LinkList link; char name; int x, y, distance; initLink(&amp;link); input(link); print(link); printf(\"请输入您要查询的城市名:\\n\"); getchar(); scanf(\"%c\", &amp;name); searchByName(link, name); printf(\"请输入您要查询的城市坐标及限定距离,格式为[X坐标 Y坐标 限定距离]:\\n\"); scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;distance); findAllCity(link, x, y, distance); return 0; } /** * 初始化链表 */ void initLink(LinkList *link) { *link = (Node *)malloc(sizeof(Node)); (*link)-&gt;next = NULL; } /** * 打印输出链表 */ void print(LinkList link) { Node *p = link-&gt;next; while (p) { printf(\"城市名：%c\\tX坐标：%d\\tY坐标：%d\\n\", p-&gt;name, p-&gt;x, p-&gt;y); p = p-&gt;next; } } /** * 首次输入链表内数据 */ void input(LinkList link) { Node *node; int time = 0; printf(\"请输入要输入的数据个数:\\n\"); scanf(\"%d\", &amp;time); printf(\"请以[城市名 X坐标 Y坐标]的格式输入数据:\\n\"); for (int i = 0; i &lt; time; i++) { getchar(); node = (Node *)malloc(sizeof(Node)); scanf(\"%c %d %d\", &amp;node-&gt;name, &amp;node-&gt;x, &amp;node-&gt;y); link-&gt;next = node; link = node; } link-&gt;next = NULL; } /** * 给定一个城市名，返回其位置坐标 * link： 链表 * name：城市名 */ void searchByName(LinkList link, char name) { Node *node = link-&gt;next; while (node) { if (name == node-&gt;name) { printf(\"X坐标：%d\\tY坐标：%d\\n\", node-&gt;x, node-&gt;y); break; } node = node-&gt;next; } } /** * 给定一个位置A坐标，距离D，返回所有与A的距离小于distance的城市名 * link： 链表 * x：x坐标 * y：y坐标 * distance：距离 */ void findAllCity(LinkList link, int x, int y, int distance) { Node *node = link-&gt;next; while (node) { if (sqrt(pow(x - node-&gt;x, 2) + pow(y - node-&gt;y, 2)) &lt;= distance ) { printf(\"城市：%c\\n\", node-&gt;name); } node = node-&gt;next; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://niithub.cn/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单向循环链表练习-约瑟夫环问题","date":"2019-05-20T05:28:00.000Z","path":"/posts/b9ea5f73/","text":"问题描述约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知n个人（以编号1，2，3…n分别表示）按顺时针方向围坐在一张圆桌周围，每个人持有一个密码（正整数）。一开始任选一个整数作为报数上限值m，从第一个人开始顺时针自1报数，报到m时停止报数，报m的那个人出列，他的密码作为新的m值，从他在顺时针方向上的下一个人又开始重新从1报数，报到m的那个人出列又出列；依此规律重复下去，直到圆桌周围的人全部出列。 输入格式 第一行一个数n，表示圆桌上做的人数； 第二行是n个整数，表示圆桌上座客持有的密码； 第三行是一个整数，表示初始m值； 输出格式 桌上座客的出队顺序 样例输入 73 1 7 2 4 8 420 样例输出 6 1 4 7 2 3 5 解题思路 本题只需要注意链表循环时，要跳过链表的头结点。 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node { int data; int index; struct Node *next;} Node, *LinkList;void initLink(LinkList *link);void create(LinkList link, int size);int main(int argc, char *argv[]) { int m = 0, n = 0, count = 1, sum = 0; // 指针p指向报数时的位置，指针q指向报数时的上一位 Node *p, *q; scanf(\"%d\", &amp;n); LinkList link; initLink(&amp;link); create(link, n); scanf(\"%d\", &amp;m); p = link-&gt;next; while (sum != n) { if (count == m) { printf(\"%d\\t\", p-&gt;index); m = p-&gt;data; q-&gt;next = p-&gt;next; free(p); p = q-&gt;next; count = 0; sum++; } else { q = p; p = p-&gt;next; } // 当指针p指向链表的头指针时，指针向后移动一位 if (p-&gt;index == -1) { q = p; p = p-&gt;next; } count++; } return 0;}void initLink(LinkList *link) { *link = (LinkList)malloc(sizeof(Node)); (*link)-&gt;next = NULL; (*link)-&gt;index = -1;}void create(LinkList link, int size) { int i; Node *node, *q; q = link; for (i = 0; i &lt; size; i++) { node = (Node *)malloc(sizeof(Node)); scanf(\"%d\", &amp;node-&gt;data); node-&gt;index = i + 1; link-&gt;next = node; link = node; } link-&gt;next = q;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://niithub.cn/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"栈-队列练习题-回文判断","date":"2019-05-20T05:27:00.000Z","path":"/posts/366dd198/","text":"问题描述试写一个算法，判断依次读入的一个以@为结束符的字母序列，是否为形如序列1&amp;序列2模式的字符序列。其中序列1和序列2中都不含字符&amp;，且序列2是序列1的逆序列。例如，a+b&amp;b+a是属于该模式的字符序列，而1+3&amp;3-1则不是。 解题思路首先将字符串以&amp;为分割点，分割成两部分，前一部分存入栈中，后一部分存入队列，而后分别出栈、出队，判断出栈、出队的元素是否一致，如果一致，则是回文数，否则不是回文数。 程序实现 C123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXSIZE 51#define FALSE 0#define TRUE 1typedef struct Stack { char elem[MAXSIZE]; int top;} Stack, *SeqStack;/*队列的数据结构*/typedef struct Queue { char data; struct Queue *next;} Queue;typedef struct LinkQueue { Queue *front; Queue *rear;} LinkQueue;/*栈操作*/void initStack(SeqStack stack);int emptyStack(SeqStack stack);int fullStack(SeqStack stack);int push(SeqStack stack, char element);int pop(SeqStack stack, char *element);/*队列操作*/int initQueue(LinkQueue *queue);int enterQueue(LinkQueue *queue, char x);int deleteQueue(LinkQueue *queue, char *x);int main(int argc, char *argv[]) { SeqStack stack; stack = (SeqStack)malloc(sizeof(Stack)); initStack(stack); LinkQueue queue; initQueue(&amp;queue); char datas[MAXSIZE]; gets(datas); int i = 0; int flag = 1; while(datas[i] != '@') { if (datas[i] == '&amp;') { flag = 0; i++; continue; } if (flag) { push(stack, datas[i++]); } else { enterQueue(&amp;queue, datas[i++]); } } char stack1, queue1; while (pop(stack, &amp;stack1) &amp;&amp; deleteQueue(&amp;queue, &amp;queue1)) { if (stack1 != queue1) { flag = 1; break; } } if (flag) { printf(\"不是回文数!\\n\"); } else { printf(\"是回文数!\\n\"); } return 0;}/** * 初始化一个空栈 */void initStack(SeqStack stack) { stack-&gt;top = -1;}/** * 判断栈是否为空 */int emptyStack(SeqStack stack) { int result = 0; if (stack-&gt;top == -1) { result = 1; } return result;}/** * 判断栈是否已满 */int fullStack(SeqStack stack) { int result = 0; if (stack-&gt;top == MAXSIZE - 1) { result = 1; } return result;}/** * 入栈操作 */int push(SeqStack stack, char element) { if (fullStack(stack)) { printf(\"栈已满!\\n\"); return -1; } stack-&gt;top++; stack-&gt;elem[stack-&gt;top] = element; return 1;}/** * 出栈操作 */int pop(SeqStack stack, char *element) { if (emptyStack(stack)) { return FALSE; } *element = stack-&gt;elem[stack-&gt;top]; stack-&gt;top--; return TRUE;}/** * 初始化队列 */int initQueue(LinkQueue *queue) { queue-&gt;front = (Queue*)malloc(sizeof(Queue)); if (queue-&gt;front != NULL) { queue-&gt;rear = queue-&gt;front; queue-&gt;front-&gt;next = NULL; return TRUE; } else { return FALSE; }}/** * 入队操作 */int enterQueue(LinkQueue *queue, char x) { Queue *newQueue; newQueue = (Queue*)malloc(sizeof(Queue)); if (newQueue != NULL) { newQueue-&gt;data = x; newQueue-&gt;next = NULL; queue-&gt;rear-&gt;next = newQueue; queue-&gt;rear = newQueue; return TRUE; } else { return FALSE; }}/** * 出队操作 */int deleteQueue(LinkQueue *queue, char *x) { Queue *p; if (queue-&gt;front == queue-&gt;rear) { return FALSE; } p = queue-&gt;front-&gt;next; queue-&gt;front-&gt;next = p-&gt;next; if(queue-&gt;rear == p) { queue-&gt;rear = queue-&gt;front; } *x = p-&gt;data; free(p); return TRUE;} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://niithub.cn/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://niithub.cn/tags/%E9%98%9F%E5%88%97/"}]},{"title":"栈的应用-括号的匹配检验","date":"2019-05-20T05:25:00.000Z","path":"/posts/e5f849e/","text":"问题描述假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序随意，即([]())或[([][])]等为正确的格式，[(]或[())]等为非法格式，试写一个算法检验括号的格式是否正确。 解题思路使用栈这种数据结构，当遇到左半边的符号时，进栈，如遇到右半边的符号时，出栈操作，如果符号不是同一队符号，则重新入栈，程序结束后，根据栈是否为空栈判断括号的格式是否正确，如果是正确，则栈为空栈，否则相反。 程序是根据严蔚敏老师的数据结构一书写就的，最后判断括号是否全匹配的操作我有点迷。 程序实现 C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/** * 栈的简单操作：判断括号是否成对 */#define STACK_INIT_SIZE 100typedef struct Stack { char *base; char *top; int stackSize;} SqStack;void initStack(SqStack *stack);int pushStack(SqStack *stack, char element);int popStack(SqStack *stack, char *element);int main(int argc, char *argv[]) { SqStack stack; initStack(&amp;stack); printf(\"请输入要匹配的括号:\\n\"); char element, result; scanf(\"%c\", &amp;element); while (element != '#') { if ((int)element == 91 || (int)element == 40) { pushStack(&amp;stack, element); } else { popStack(&amp;stack, &amp;result); if ((element == ']' &amp;&amp; result != '[') || (element == ')' &amp;&amp; result != '(')) { pushStack(&amp;stack, result); } } getchar(); scanf(\"%c\", &amp;element); } if (*stack.top == *stack.base) { printf(\"括号全匹配!\"); } else { printf(\"括号匹配失败!\"); } return 0;}/** * 初始化栈 */void initStack(SqStack *stack) { stack-&gt;base = (char *)malloc(STACK_INIT_SIZE * sizeof(char)); if (!stack-&gt;base) { exit(-1); } stack-&gt;stackSize = 100; stack-&gt;top = stack-&gt;base;}/** * 入栈操作 */int pushStack(SqStack *stack, char element) { // 栈已满 if (stack-&gt;top - stack-&gt;base &gt;= stack-&gt;stackSize) { return -1; } *stack-&gt;top++ = element; return 1;}/** * 出栈操作 */int popStack(SqStack *stack, char *element) { // 栈已空 if (stack-&gt;top == stack-&gt;base) { return -1; } *element = *--stack-&gt;top; return 1;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://niithub.cn/tags/%E6%A0%88/"}]},{"title":"非递归实现后序遍历二叉树","date":"2019-05-20T05:24:00.000Z","path":"/posts/3b1b93e6/","text":"问题描述从键盘接受输入先序序列，以二叉链表作为存储结构，建立二叉树（以先序来建立）并对其进行后序遍历，然后将遍历结果打印输出。要求采用非递归方法实现。 解题思路 Push根结点到第一个栈stack1中 从第一个栈stack1中Pop出一个结点，并将其Push到第二个栈stack2中 然后Push结点的左孩子和右孩子到第一个栈stack1中 重复过程2和3直到栈stack1为空 完成后，所有结点已经Push到栈stack2中，且按照后序遍历的顺序存放，直接全部Pop出来即是二叉树后序遍历结果 程序实现 C123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FALSE 0#define TRUE 1typedef char Datatype;/*二叉树*/typedef struct Node { Datatype data; struct Node *LChild; struct Node *RChild;} BiTNode, *BiTree;/*链栈*/typedef struct Stack { struct Node *node; struct Stack *next;} Stack, *SeqStack;typedef struct { SeqStack top; int count;} LinkStack;/*栈操作*/int initStack(LinkStack *stack);int emptyStack(LinkStack *stack);int push(LinkStack *stack, BiTree tree);BiTree pop(LinkStack *stack);void createBiTree(BiTree *tree);void traverseTree(BiTree tree, LinkStack *stack1, LinkStack *stack2);int main(int argc, char *argv[]) { BiTree tree; printf(\"按先序遍历序列建立二叉树:\\n\"); createBiTree(&amp;tree); LinkStack stack1, stack2; initStack(&amp;stack1); initStack(&amp;stack2); printf(\"使用栈后序输出二叉树:\\n\"); traverseTree(tree, &amp;stack1, &amp;stack2); return 0;}/** * 初始化一个空栈 */int initStack(LinkStack *stack) { stack-&gt;top = (SeqStack)malloc(sizeof(Stack)); if(!stack-&gt;top) { return FALSE; } stack-&gt;top = NULL; stack-&gt;count = 0; return TRUE;}/** * 判断栈是否为空 */int emptyStack(LinkStack *stack) { int result = 0; if (stack-&gt;count == 0) { result = 1; } return result;}/** * 入栈操作 */int push(LinkStack *stack, BiTree tree) { SeqStack s = (SeqStack)malloc(sizeof(Stack)); s-&gt;node = tree; s-&gt;next = stack-&gt;top; /* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */ stack-&gt;top = s; /* 将新的结点s赋值给栈顶指针，见图中② */ stack-&gt;count++; return 1;}/** * 出栈操作 */BiTree pop(LinkStack *stack) { BiTree tree; SeqStack p; if (emptyStack(stack)) { return FALSE; } tree = stack-&gt;top-&gt;node; /*将栈顶结点赋值给p*/ p = stack-&gt;top; /*使得栈顶指针下移一位，指向后一结点*/ stack-&gt;top = stack-&gt;top-&gt;next; /* 释放结点p */ free(p); stack-&gt;count--; return tree;}void createBiTree(BiTree *tree) { char ch; ch = getchar(); if(ch == ' ') { *tree = NULL; } else { //生成一个新结点 *tree = (BiTree)malloc(sizeof(BiTNode)); (*tree)-&gt;data = ch; //生成左子树 createBiTree(&amp;((*tree)-&gt;LChild)); //生成右子树 createBiTree(&amp;((*tree)-&gt;RChild)); }}/**遍历树的结点*//*定义了两个栈接受后序遍历的结果*/ void traverseTree(BiTree tree, LinkStack *stack1, LinkStack *stack2) { if(tree == NULL) { return; } BiTree root = tree; push(stack1, root); while (!emptyStack(stack1)) { BiTree t = stack1-&gt;top-&gt;node; push(stack2, t); pop(stack1); if (t-&gt;LChild != NULL) { push(stack1, t-&gt;LChild); } if (t-&gt;RChild != NULL) { push(stack1, t-&gt;RChild); } } root = pop(stack2); printf(\"%c \", root-&gt;data); while (!emptyStack(stack2)) { root = pop(stack2); printf(\"%c \", root-&gt;data); }} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://niithub.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"非递归实现中序遍历二叉树","date":"2019-05-20T05:23:00.000Z","path":"/posts/a634667c/","text":"问题描述从键盘接受输入先序序列，以二叉链表作为存储结构，建立二叉树（以先序来建立）并对其进行中序遍历，然后将遍历结果打印输出。要求采用非递归方法实现。 解题思路 使用栈中间存储树的结点 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FALSE 0#define TRUE 1typedef char Datatype;/*二叉树*/typedef struct Node { Datatype data; struct Node *LChild; struct Node *RChild;} BiTNode, *BiTree;/*链栈*/typedef struct Stack { struct Node *node; struct Stack *next;} Stack, *SeqStack;typedef struct { SeqStack top; int count;} LinkStack;/*栈操作*/int initStack(LinkStack *stack);int emptyStack(LinkStack *stack);int push(LinkStack *stack, BiTree tree);BiTree pop(LinkStack *stack);void createBiTree(BiTree *tree);void traverseTree(BiTree tree, LinkStack *stack);int main(int argc, char *argv[]) { BiTree tree; printf(\"按先序遍历序列建立二叉树:\\n\"); createBiTree(&amp;tree); LinkStack stack; initStack(&amp;stack); printf(\"使用栈后序输出二叉树:\\n\"); traverseTree(tree, &amp;stack); return 0;}/** * 初始化一个空栈 */int initStack(LinkStack *stack) { stack-&gt;top = (SeqStack)malloc(sizeof(Stack)); if(!stack-&gt;top) { return FALSE; } stack-&gt;top = NULL; stack-&gt;count = 0; return TRUE;}/** * 判断栈是否为空 */int emptyStack(LinkStack *stack) { int result = 0; if (stack-&gt;count == 0) { result = 1; } return result;}/** * 入栈操作 */int push(LinkStack *stack, BiTree tree) { SeqStack s = (SeqStack)malloc(sizeof(Stack)); s-&gt;node = tree; s-&gt;next = stack-&gt;top; /* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */ stack-&gt;top = s; /* 将新的结点s赋值给栈顶指针，见图中② */ stack-&gt;count++; return 1;}/** * 出栈操作 */BiTree pop(LinkStack *stack) { BiTree tree; SeqStack p; if (emptyStack(stack)) { return FALSE; } tree = stack-&gt;top-&gt;node; /*将栈顶结点赋值给p*/ p = stack-&gt;top; /*使得栈顶指针下移一位，指向后一结点*/ stack-&gt;top = stack-&gt;top-&gt;next; /* 释放结点p */ free(p); stack-&gt;count--; return tree;}void createBiTree(BiTree *tree) { char ch; ch = getchar(); if(ch == ' ') { *tree = NULL; } else { //生成一个新结点 *tree = (BiTree)malloc(sizeof(BiTNode)); (*tree)-&gt;data = ch; //生成左子树 createBiTree(&amp;((*tree)-&gt;LChild)); //生成右子树 createBiTree(&amp;((*tree)-&gt;RChild)); }}/**遍历树的结点*/void traverseTree(BiTree tree, LinkStack *stack) { if(tree == NULL) { return; } BiTree root = tree; while (root != NULL || !emptyStack(stack)) { if (root != NULL) { push(stack, root); root = root-&gt;LChild; } else { root = pop(stack); printf(\"%c \", root-&gt;data); root = root-&gt;RChild; } }} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://niithub.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"非递归实现先序遍历二叉树","date":"2019-05-20T05:20:00.000Z","path":"/posts/6d8be3cf/","text":"问题描述从键盘接受输入先序序列，以二叉链表作为存储结构，建立二叉树（以先序来建立）并对其进行先序遍历，然后将遍历结果打印输出。要求采用非递归方法实现。 解题思路 使用栈中间存储树的结点 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FALSE 0#define TRUE 1typedef char Datatype;/*二叉树*/typedef struct Node { Datatype data; struct Node *LChild; struct Node *RChild;} BiTNode, *BiTree;/*链栈*/typedef struct Stack { struct Node *node; struct Stack *next;} Stack, *SeqStack;typedef struct { SeqStack top; int count;} LinkStack;/*栈操作*/int initStack(LinkStack *stack);int emptyStack(LinkStack *stack);int push(LinkStack *stack, BiTree tree);BiTree pop(LinkStack *stack);void createBiTree(BiTree *tree);void traverseTree(BiTree tree, LinkStack *stack);int main(int argc, char *argv[]) { BiTree tree; printf(\"按先序遍历序列建立二叉树:\\n\"); createBiTree(&amp;tree); LinkStack stack; initStack(&amp;stack); printf(\"使用栈先序输出二叉树:\\n\"); traverseTree(tree, &amp;stack); return 0;}/** * 初始化一个空栈 */int initStack(LinkStack *stack) { stack-&gt;top = (SeqStack)malloc(sizeof(Stack)); if(!stack-&gt;top) { return FALSE; } stack-&gt;top = NULL; stack-&gt;count = 0; return TRUE;}/** * 判断栈是否为空 */int emptyStack(LinkStack *stack) { int result = 0; if (stack-&gt;count == 0) { result = 1; } return result;}/** * 入栈操作 */int push(LinkStack *stack, BiTree tree) { SeqStack s = (SeqStack)malloc(sizeof(Stack)); s-&gt;node = tree; s-&gt;next = stack-&gt;top; /* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */ stack-&gt;top = s; /* 将新的结点s赋值给栈顶指针，见图中② */ stack-&gt;count++; return 1;}/** * 出栈操作 */BiTree pop(LinkStack *stack) { BiTree tree; SeqStack p; if (emptyStack(stack)) { return FALSE; } tree = stack-&gt;top-&gt;node; /*将栈顶结点赋值给p*/ p = stack-&gt;top; /*使得栈顶指针下移一位，指向后一结点*/ stack-&gt;top = stack-&gt;top-&gt;next; /* 释放结点p */ free(p); stack-&gt;count--; return tree;}void createBiTree(BiTree *tree) { char ch; ch = getchar(); if(ch == ' ') { *tree = NULL; } else { //生成一个新结点 *tree = (BiTree)malloc(sizeof(BiTNode)); (*tree)-&gt;data = ch; //生成左子树 createBiTree(&amp;((*tree)-&gt;LChild)); //生成右子树 createBiTree(&amp;((*tree)-&gt;RChild)); }}/**遍历树的结点*/void traverseTree(BiTree tree, LinkStack *stack) { if(tree == NULL) { return; } BiTree root = tree; push(stack, root); while (!emptyStack(stack)) { root = pop(stack); printf(\"%c \", root-&gt;data); if (root-&gt;RChild != NULL) { push(stack, root-&gt;RChild); } if (root-&gt;LChild != NULL) { push(stack, root-&gt;LChild); } }} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://niithub.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"CentOS7虚拟机环境下配置无线上网","date":"2019-05-17T08:17:00.000Z","path":"/posts/6bbe03e9/","text":"设备条件VMware 版本：VMware® Workstation 12 Pro Linux 版本：CentOS-7-x86_64-DVD-1810 宿主机：Window10 Education版，无线网连接正常 操作步骤打开虚拟网络编辑器 点击 更改设置 将VMnet0的类型设置为桥接模式，桥接到 自动 点选要设置网络连接的操作系统，更改网络适配器选项，改为桥接模式 启动虚拟机内的操作系统，连接到网络 验证网络是否正常 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://niithub.cn/tags/CentOS/"},{"name":"安装记录","slug":"安装记录","permalink":"https://niithub.cn/tags/%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"}]},{"title":"起步能力自测题-3 数组元素循环右移问题","date":"2019-05-17T05:28:00.000Z","path":"/posts/45cb7ec1/","text":"题目描述 输入格式每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例 6 21 2 3 4 5 6 输出样例 5 6 1 2 3 4 解题思路 读入整数序列及偏移量 定义数组，填充整数序列 定义偏移函数，每次将数组向后移动一位，并将数组末位移动至数组头 根据偏移量，循环调用若干次偏移函数 程序实现 C 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;math.h&gt;void moveOneOffset(int number, int *zero);int main(int argc, char *argv) { int number, offset; int i; scanf(\"%d %d\", &amp;number, &amp;offset); int array[100]; for( i = 0; i &lt; number; i++) { scanf(\"%d\", &amp;array[i]); } for( i = 0; i &lt; offset; i++) { moveOneOffset(number, array); } for( i = 0; i &lt; number; i++) { printf(\"%d\", array[i]); if (i &lt; number - 1) { printf(\" \"); } } return 0;}void moveOneOffset(int number, int *zero) { int temporary = 0; temporary = *(zero + number - 1); int i = number - 1; while (i &gt; 0) { *(zero + i) = *(zero + i - 1); i--; } *zero = temporary;} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PAT","slug":"PAT","permalink":"https://niithub.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"基础题","slug":"基础题","permalink":"https://niithub.cn/tags/%E5%9F%BA%E7%A1%80%E9%A2%98/"}]},{"title":"起步能力自测题-2 素数对猜想","date":"2019-05-17T05:22:00.000Z","path":"/posts/d490bba8/","text":"问题描述 输入格式输入在一行给出正整数N。 输出格式在一行中输出不超过N的满足猜想的素数对的个数。 输入样例:20 输出样例:4 解题思路： 读入范围 循环遍历范围内的数，判断是否是素数，如果是素数，则存入数组 遍历素数数组，判断两素数之差是否为2，如果为2，计数加1 输出计数结果 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;math.h&gt;int checkPrime(int number);int main(int argc, char *argv) { int number; int i; scanf(\"%d\", &amp;number); int array[10000]; int index = 0; int sum = 0; int *zero; for( i = 2; i &lt;= number; i++) { if (checkPrime(i)) { array[index] = i; index++; } } zero = array; int location = 0; for (location = 0; location &lt; index+1; location++) { if(*(zero + location + 1) - *(zero + location) == 2) { sum++; } } printf(\"%d\", sum); return 0;} int checkPrime(int number) { int i = 2, result = 1; for (i; i &lt;= sqrt(number); i++) { if (number % i == 0) { result = 0; break; } } return result; } 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PAT","slug":"PAT","permalink":"https://niithub.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"基础题","slug":"基础题","permalink":"https://niithub.cn/tags/%E5%9F%BA%E7%A1%80%E9%A2%98/"}]},{"title":"起步能力自测题-1 打印沙漏","date":"2019-05-17T05:09:00.000Z","path":"/posts/c54ee48/","text":"问题描述本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 ***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。 输出格式首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例 19 * 输出样例 ***** *** * ******** 解题思路： 读入要打印的字符数，字符 计算出单向最大层数 定义宏函数，求解层数对应的字符数 遍历层数，并根据最大层数的字符数与当前层数的字符数之差，打印每层空格 打印根据层数计算出的对应字符次数 打印顺序为： 最外层-&gt;1字符层-&gt;最外层 打印剩余的字符数 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define SUM(number) (3 + (number - 1) * 2)void printGraph(int number, char graph, int count);int main(int argc, char *argv) { int number; int index = 0; int sum = 0; int div = 0; int count = 0; char graph; scanf(\"%d %c\", &amp;number, &amp;graph); if(number &lt; 0 || number &gt; 1000) { return 0; } div = (number-1) / 2; while(sum &lt;= div) { index++; sum = index * (index + 2); } index--; sum = SUM(index); for (count = index; count &gt;= 1; count--) { printGraph(count, graph, sum); } printGraph(0, graph, sum); for (count = 1; count &lt;= index; count++) { printGraph(count, graph, sum); } printf(\"%d\", number - 1 - index * (index +2 ) * 2); return 0;}void printGraph(int number, char graph, int sum) { int index = 0; int count = (sum - SUM(number)) / 2; int a = 0; char kong = ' '; for (a = 0; a &lt; count; a++) { printf(\"%c\", kong); } for (index; index &lt; SUM(number); index++) { printf(\"%c\", graph); } printf(\"\\n\");} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PAT","slug":"PAT","permalink":"https://niithub.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://niithub.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"基础题","slug":"基础题","permalink":"https://niithub.cn/tags/%E5%9F%BA%E7%A1%80%E9%A2%98/"}]},{"title":"Git常用操作命令","date":"2019-05-16T04:23:00.000Z","path":"/posts/656d75c5/","text":"打标签 列显已有的标签 123$ git tagv0.1v1.3 新建含附注的标签 -a （译注：取 annotated 的首字母）指定标签名字 12345$ git tag -a v1.4 -m 'my version 1.4'$ git tagv0.1v1.3v1.4 查看相应标签的版本信息 12345678910111213$ git show v1.4tag v1.4Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Feb 9 14:45:11 2009 -0800my version 1.4commit 15027957951b64cf874c3557a0f3547bd83b3ff6Merge: 4a447f7... a6b4c97...Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sun Feb 8 19:02:46 2009 -0800 Merge branch 'experiment' 分享标签 git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 git push origin [tagname] 即可 1234567 &nbsp;$ git push origin v1.5Counting objects: 50, done.Compressing objects: 100% (38/38), done.Writing objects: 100% (44/44), 4.56 KiB, done.Total 44 (delta 18), reused 8 (delta 1)To git@github.com:schacon/simplegit.git* [new tag] v1.5 -&gt; v1.5 分支操作 查看本地所有分支 1git branch 切换分支 1git checkout master 强制切换分支 1git checkout -f master 拉取远程新分支 1git fetch origin 远程分支名:本地分支名 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"git","slug":"git","permalink":"https://niithub.cn/tags/git/"},{"name":"常用命令","slug":"常用命令","permalink":"https://niithub.cn/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]},{"title":"递归实现先序遍历二叉树","date":"2019-05-15T11:00:00.000Z","path":"/posts/f2a970c3/","text":"问题描述从键盘接受输入先序序列，以二叉链表作为存储结构，建立二叉树（以先序来建立）并对其进行先序遍历，然后将遍历结果打印输出。要求采用递归方法实现。 解题思路 递归实现 程序实现 CPP 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char Datatype;// 二叉树typedef struct Node { Datatype data; struct Node *LChild; struct Node *RChild;} BiTNode, *BiTree;void createBiTree(BiTree *tree);void traverseTree(BiTree tree); int main(int argc, char *argv[]) { BiTree tree; printf(\"按先序遍历序列建立二叉树:\\n\"); createBiTree(&amp;tree); traverseTree(tree); return 0;}void createBiTree(BiTree *tree) { char ch; ch = getchar(); if(ch == ' ') { *tree = NULL; } else { //生成一个新结点 *tree = (BiTree)malloc(sizeof(BiTNode)); (*tree)-&gt;data = ch; //生成左子树 createBiTree(&amp;((*tree)-&gt;LChild)); //生成右子树 createBiTree(&amp;((*tree)-&gt;RChild)); }}// 遍历树的结点void traverseTree(BiTree tree) { int i; if(tree == NULL) { return; } printf(\"%c\", tree-&gt;data); traverseTree(tree-&gt;LChild); traverseTree(tree-&gt;RChild);} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://niithub.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"递归","slug":"递归","permalink":"https://niithub.cn/tags/%E9%80%92%E5%BD%92/"}]},{"title":"递归实现后序遍历二叉树","date":"2019-05-15T10:58:00.000Z","path":"/posts/a43900ea/","text":"问题描述从键盘接受输入先序序列，以二叉链表作为存储结构，建立二叉树（以先序来建立）并对其进行中序遍历，然后将遍历结果打印输出。要求采用递归方法实现。 解题思路 递归实现 程序实现 CPP12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char Datatype;/*二叉树*/typedef struct Node { Datatype data; struct Node *LChild; struct Node *RChild;} BiTNode, *BiTree;void createBiTree(BiTree *tree);void traverseTree(BiTree tree); int main(int argc, char *argv[]) { BiTree tree; printf(\"按先序遍历序列建立二叉树:\\n\"); createBiTree(&amp;tree); traverseTree(tree); return 0;}void createBiTree(BiTree *tree) { char ch; ch = getchar(); if(ch == ' ') { *tree = NULL; } else { //生成一个新结点 *tree = (BiTree)malloc(sizeof(BiTNode)); (*tree)-&gt;data = ch; //生成左子树 createBiTree(&amp;((*tree)-&gt;LChild)); //生成右子树 createBiTree(&amp;((*tree)-&gt;RChild)); }}/**遍历树的结点*/void traverseTree(BiTree tree) { int i; if(tree == NULL) { return; } traverseTree(tree-&gt;LChild); printf(\"%c\", tree-&gt;data); traverseTree(tree-&gt;RChild);} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://niithub.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"递归","slug":"递归","permalink":"https://niithub.cn/tags/%E9%80%92%E5%BD%92/"}]},{"title":"使用邻接矩阵存储无向图","date":"2019-05-15T10:52:00.000Z","path":"/posts/5bf8c406/","text":"问题描述 使用邻接矩阵存储下图所示无向图 解题思路创建一个邻接矩阵 程序实现 CPP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MAXVEX 10/* Status是函数的类型,其值是函数结果状态代码，如OK等 */typedef int Status;/* 顶点类型应由用户定义 */typedef char VertexType;/* 边上的权值类型应由用户定义 */typedef int EdgeType;typedef struct { VertexType vex[MAXVEX]; EdgeType arc[MAXVEX][MAXVEX]; int numNodes, numEdges;} MyGraph, *GraphPlus;void CreateMyGraph(GraphPlus *plus);int main(void) { int i, j; GraphPlus plus; CreateMyGraph(&amp;plus); for (i = 0; i &lt; plus-&gt;numNodes; i++) { for (j = 0; j &lt; plus-&gt;numNodes; j++) { printf(\"%d\\t\", plus-&gt;arc[i][j]); } printf(\"\\n\"); }}void CreateMyGraph(GraphPlus *plus) { int i, j, k, w; printf(\"请输入顶点数和边数:\\n\"); scanf(\"%d,%d\", &amp;i, &amp;j); *plus = (GraphPlus)malloc(sizeof(MyGraph)); getchar(); (*plus)-&gt;numNodes = i; (*plus)-&gt;numEdges = j; // 读入顶点数 for (i = 0; i &lt; (*plus)-&gt;numNodes; i++) { scanf(\"%c\", &amp;(*plus)-&gt;vex[i]); } // 初始化边数组 for (i = 0; i &lt; (*plus)-&gt;numNodes; i++) { for (j = 0; j &lt; (*plus)-&gt;numNodes; j++) { (*plus)-&gt;arc[i][j]=0; } } // 读入numEdges条边，建立邻接矩阵 for(k = 0; k &lt; (*plus)-&gt;numEdges; k++) { printf(\"输入边(vi,vj)上的下标i，下标j:\\n\"); scanf(\"%d,%d\", &amp;i, &amp;j); (*plus)-&gt;arc[i][j] = 1; // 因为是无向图，矩阵对称 (*plus)-&gt;arc[j][i] = (*plus)-&gt;arc[i][j]; }} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://niithub.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"无向图","slug":"无向图","permalink":"https://niithub.cn/tags/%E6%97%A0%E5%90%91%E5%9B%BE/"},{"name":"邻接矩阵","slug":"邻接矩阵","permalink":"https://niithub.cn/tags/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/"}]},{"title":"使用邻接表存储无向图","date":"2019-05-15T10:41:00.000Z","path":"/posts/d8bdf311/","text":"问题描述 使用邻接表存储下图所示无向图 解题思路创建一个邻接表接受无向图信息 程序实现 CPP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MAXVEX 10/* Status是函数的类型,其值是函数结果状态代码，如OK等 */typedef int Status;/* 顶点类型应由用户定义 */typedef char VertexType;/* 边上的权值类型应由用户定义 */typedef int EdgeType;typedef struct EdgeNode { // 邻接点域,存储该顶点对应的下标 int adjvex; // 链域,指向下一个邻接点 struct EdgeNode *next;} EdgeNode;// 顶点表结点typedef struct VertexNode { // 顶点域,存储顶点信息 VertexType data; // 边表头指针 EdgeNode *firstedge;} VertexNode, AdjList[MAXVEX];typedef struct { AdjList adjList; // 图中当前顶点数和边数 int numNodes; int numEdges;} GraphAdjList, *GraphList;void CreateMyGraph(GraphList *plus);int main(void) { int i, j; GraphList plus; CreateMyGraph(&amp;plus); for (i = 0; i &lt; plus-&gt;numNodes; i++) { printf(\"%c:\\t\", plus-&gt;adjList[i].data); EdgeNode *e; e = plus-&gt;adjList[i].firstedge; while (e != NULL) { printf(\"%c\\t\", plus-&gt;adjList[e-&gt;adjvex].data); e = e-&gt;next; } free(e); printf(\"\\n\"); }}void CreateMyGraph(GraphList *plus) { int i, j, k, w; EdgeNode *e; printf(\"请输入顶点数和边数:\\n\"); scanf(\"%d,%d\", &amp;i, &amp;j); *plus = (GraphList)malloc(sizeof(GraphAdjList)); getchar(); (*plus)-&gt;numNodes = i; (*plus)-&gt;numEdges = j; // 读入顶点数 for (i = 0; i &lt; (*plus)-&gt;numNodes; i++) { // 输入顶点信息 scanf(\"%c\", &amp;(*plus)-&gt;adjList[i].data); // 将边表置为空表 (*plus)-&gt;adjList[i].firstedge=NULL; } // 读入numEdges条边，建立邻接矩阵 for(k = 0; k &lt; (*plus)-&gt;numEdges; k++) { printf(\"输入边(vi,vj)上的下标i,下标j:\\n\"); scanf(\"%d,%d\", &amp;i, &amp;j); // 向内存申请空间,生成边表结点 e = (EdgeNode *)malloc(sizeof(EdgeNode)); // 邻接序号为j e-&gt;adjvex = j; // 将e的指针指向当前顶点上指向的结点 e-&gt;next = (*plus)-&gt;adjList[i].firstedge; // 将当前顶点的指针指向e (*plus)-&gt;adjList[i].firstedge = e; // 因为是无向图，所以需对称存储 // 向内存申请空间,生成边表结点 e=(EdgeNode *)malloc(sizeof(EdgeNode)); // 邻接序号为i e-&gt;adjvex=i; // 将e的指针指向当前顶点上指向的结点 e-&gt;next= (*plus)-&gt;adjList[j].firstedge; // 将当前顶点的指针指向e (*plus)-&gt;adjList[j].firstedge=e; }} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://niithub.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"无向图","slug":"无向图","permalink":"https://niithub.cn/tags/%E6%97%A0%E5%90%91%E5%9B%BE/"},{"name":"邻接表","slug":"邻接表","permalink":"https://niithub.cn/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"}]},{"title":"Linux常用命令","date":"2019-05-15T10:29:00.000Z","path":"/posts/d0edc1ed/","text":"基础操作查看IP1ip address show 登陆1ssh name@address 后台运行进程1shell &amp; 修改文件夹的所有者12chown [-cfhvR] [--help] [--version] user[:group] file... user : 新的文件拥有者的使用者 group : 新的文件拥有者的使用者组(group) c : 显示更改的部分的信息 f : 忽略错误信息 h :修复符号链接 v : 显示详细的处理信息 R : 处理指定目录以及其子目录下的所有文件 help : 显示辅助说明 version : 显示版本 示例 1chown -R user:userGroup * 将目前目录下的所有文件与子目录的拥有者皆设为 user，所属群组是 userGroup 用户及用户组基础操作 创建用户 1useradd username 设置密码 1passwd username FTP相关操作基础操作 启用FTP服务 1service vsftpd start 访问FTP命令 1ftp IP地址 username password 上传文件 1put 文件名（带路径） 下载文件 1get 文件名 下载到本地路径\\文件名 定时任务定时器基本操作 crontab时间表达式 12* * * * * command分 时 日 月 周 命令 启动服务 1service crond start 查看crontab服务状态 1service crond status 关闭服务 1service crond stop 重启服务 1service crond restart 重新载入配置 1service crond reload 查看crontab服务是否已设置为开机启动，执行命令 1ntsysv 加入开机自动启动 1chkconfig –level 35 crond on 设置定时任务 追加定时任务 12345 [root@root test]# crontab -e00 02 * * * sh /home/admin/optbash/dailyBackup.sh00 02 * * * sh /home/admin/optbash/deleteDebugSql.sh\\* * * * * sh /home/admin/test/test.sh 查看定时任务 1crontab -l document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"https://niithub.cn/tags/Linux/"}]},{"title":"深度优先搜索邻接表存储结构下的无向图","date":"2019-05-14T05:30:00.000Z","path":"/posts/84ed6062/","text":"问题描述 使用邻接表存储下图所示无向图，使用深度优先搜索遍历无向图上的各节点 解题思路1、创建一个邻接表接受无向图信息 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MAXVEX 10#define TRUE 1#define FALSE 0/* Status是函数的类型,其值是函数结果状态代码，如OK等 */typedef int Status;/* 顶点类型应由用户定义 */typedef char VertexType;/* 边上的权值类型应由用户定义 */typedef int EdgeType;/* 邻接表的数据结构 */typedef struct EdgeNode { // 邻接点域,存储该顶点对应的下标 int adjvex; // 链域,指向下一个邻接点 struct EdgeNode *next;} EdgeNode;// 顶点表结点typedef struct VertexNode { // 顶点域,存储顶点信息 VertexType data; // 边表头指针 EdgeNode *firstedge;} VertexNode, AdjList[MAXVEX];typedef struct { AdjList adjList; // 图中顶点数 int numNodes; // 图中边数 int numEdges;} GraphAdjList, *GraphList;void createMyGraph(GraphList *plus);void DFS(GraphList plus, int i);void DFSTraverse(GraphList plus);int main(void) { int i, j; GraphList plus; createMyGraph(&amp;plus); for (i = 0; i &lt; plus-&gt;numNodes; i++) { printf(\"%c:\\t\", plus-&gt;adjList[i].data); EdgeNode *e; e = plus-&gt;adjList[i].firstedge; while (e != NULL) { printf(\"%c\\t\", plus-&gt;adjList[e-&gt;adjvex].data); e = e-&gt;next; } free(e); printf(\"\\n\"); } printf(\"\\n深度优先搜素：\\n\"); DFSTraverse(plus); }/** * 创建无向图 */void createMyGraph(GraphList *plus) { int i, j, k, w; EdgeNode *e; printf(\"请输入顶点数和边数:\\n\"); scanf(\"%d,%d\", &amp;i, &amp;j); *plus = (GraphList)malloc(sizeof(GraphAdjList)); getchar(); (*plus)-&gt;numNodes = i; (*plus)-&gt;numEdges = j; // 读入顶点数 for (i = 0; i &lt; (*plus)-&gt;numNodes; i++) { // 输入顶点信息 scanf(\"%c\", &amp;(*plus)-&gt;adjList[i].data); // 将边表置为空表 (*plus)-&gt;adjList[i].firstedge=NULL; } // 读入numEdges条边，建立邻接矩阵 for(k = 0; k &lt; (*plus)-&gt;numEdges; k++) { printf(\"输入边(vi,vj)上的下标i,下标j:\\n\"); scanf(\"%d,%d\", &amp;i, &amp;j); // 向内存申请空间,生成边表结点 e = (EdgeNode *)malloc(sizeof(EdgeNode)); // 邻接序号为j e-&gt;adjvex = j; // 将e的指针指向当前顶点上指向的结点 e-&gt;next = (*plus)-&gt;adjList[i].firstedge; // 将当前顶点的指针指向e (*plus)-&gt;adjList[i].firstedge = e; // 因为是无向图，所以需对称存储 // 向内存申请空间,生成边表结点 e=(EdgeNode *)malloc(sizeof(EdgeNode)); // 邻接序号为i e-&gt;adjvex=i; // 将e的指针指向当前顶点上指向的结点 e-&gt;next= (*plus)-&gt;adjList[j].firstedge; // 将当前顶点的指针指向e (*plus)-&gt;adjList[j].firstedge=e; }}// 访问标志的数组int visited[MAXVEX];/** * 邻接表的深度优先搜索操作 */ void DFS(GraphList plus, int i) { EdgeNode *p; visited[i] = TRUE; printf(\"%c \",plus-&gt;adjList[i].data); p = plus-&gt;adjList[i].firstedge; while(p) { if(!visited[p-&gt;adjvex]) { // 对为访问的邻接顶点递归调用 DFS(plus, p-&gt;adjvex); } p = p-&gt;next; }}void DFSTraverse(GraphList plus) { int i; // 初始所有顶点状态都是未访问过状态 for(i = 0; i &lt; plus-&gt;numNodes; i++) { visited[i] = FALSE; } for(i = 0; i &lt; plus-&gt;numNodes; i++) { // 对未访问过的顶点调用DFS,若是连通图,只会执行一次 if(!visited[i]) { DFS(plus, i); } }} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://niithub.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"广度优先搜索邻接表存储结构下的无向图","date":"2019-05-14T05:17:00.000Z","path":"/posts/0/","text":"问题描述使用邻接表存储下图所示无向图，使用广度优先搜索遍历无向图上的各节点 解题思路 创建一个邻接表接受无向图信息 创建队列接受已经访问过的节点 始自图中顶点开始搜索，将首先访问顶点；再依次访问顶点所有未访问到的邻居；再按后者被访问的先后次序，逐个访问它们的邻居；如此不断，直至所有的点均被访问过 程序实现 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MAXVEX 10#define TRUE 1#define FALSE 0/* Status是函数的类型,其值是函数结果状态代码，如OK等 */typedef int Status;/* 顶点类型应由用户定义 */typedef char VertexType;/* 边上的权值类型应由用户定义 */typedef int EdgeType;/* 邻接表的数据结构 */typedef struct EdgeNode { // 邻接点域,存储该顶点对应的下标 int adjvex; // 链域,指向下一个邻接点 struct EdgeNode *next;} EdgeNode;// 顶点表结点typedef struct VertexNode { // 顶点域,存储顶点信息 VertexType data; // 边表头指针 EdgeNode *firstedge;} VertexNode, AdjList[MAXVEX];typedef struct { AdjList adjList; // 图中顶点数 int numNodes; // 图中边数 int numEdges;} GraphAdjList, *GraphList;/* 队列的数据结构 */typedef struct { int data[MAXVEX]; int front; int rear;} Queue;Status initQueue(Queue *q);Status emptyQueue(Queue *q);Status enterQueue(Queue *q, int data);void createMyGraph(GraphList *plus);void BFS(GraphList plus);int main(void) { int i, j; GraphList plus; createMyGraph(&amp;plus); for (i = 0; i &lt; plus-&gt;numNodes; i++) { printf(\"%c:\\t\", plus-&gt;adjList[i].data); EdgeNode *e; e = plus-&gt;adjList[i].firstedge; while (e != NULL) { printf(\"%c\\t\", plus-&gt;adjList[e-&gt;adjvex].data); e = e-&gt;next; } free(e); printf(\"\\n\"); } BFS(plus);}/** * 初始化队列 */Status initQueue(Queue *q) { q-&gt;front = 0; q-&gt;rear = 0; return TRUE;}/** * 判断队列是否为空 */Status emptyQueue(Queue *q) { if (q-&gt;front == q-&gt;rear) { return TRUE; } else { return FALSE; }}/** * 入队操作 */Status enterQueue(Queue *q, int data) { if ((q-&gt;rear + 1) % MAXVEX == q-&gt;front) { return FALSE; } q-&gt;data[q-&gt;rear] = data; q-&gt;rear = (q-&gt;rear + 1) % MAXVEX; return TRUE;}/** * 出队操作 */Status deQueue(Queue *q, int *e) { if (emptyQueue(q)) { return FALSE; } *e = q-&gt;data[q-&gt;front]; q-&gt;front = (q-&gt;front + 1) % MAXVEX; return TRUE;}/** * 创建无向图 */void createMyGraph(GraphList *plus) { int i, j, k, w; EdgeNode *e; printf(\"请输入顶点数和边数:\\n\"); scanf(\"%d,%d\", &amp;i, &amp;j); *plus = (GraphList)malloc(sizeof(GraphAdjList)); getchar(); (*plus)-&gt;numNodes = i; (*plus)-&gt;numEdges = j; // 读入顶点数 for (i = 0; i &lt; (*plus)-&gt;numNodes; i++) { // 输入顶点信息 scanf(\"%c\", &amp;(*plus)-&gt;adjList[i].data); // 将边表置为空表 (*plus)-&gt;adjList[i].firstedge=NULL; } // 读入numEdges条边，建立邻接矩阵 for(k = 0; k &lt; (*plus)-&gt;numEdges; k++) { printf(\"输入边(vi,vj)上的下标i,下标j:\\n\"); scanf(\"%d,%d\", &amp;i, &amp;j); // 向内存申请空间,生成边表结点 e = (EdgeNode *)malloc(sizeof(EdgeNode)); // 邻接序号为j e-&gt;adjvex = j; // 将e的指针指向当前顶点上指向的结点 e-&gt;next = (*plus)-&gt;adjList[i].firstedge; // 将当前顶点的指针指向e (*plus)-&gt;adjList[i].firstedge = e; // 因为是无向图，所以需对称存储 // 向内存申请空间,生成边表结点 e=(EdgeNode *)malloc(sizeof(EdgeNode)); // 邻接序号为i e-&gt;adjvex=i; // 将e的指针指向当前顶点上指向的结点 e-&gt;next= (*plus)-&gt;adjList[j].firstedge; // 将当前顶点的指针指向e (*plus)-&gt;adjList[j].firstedge=e; }}// 访问标志的数组int visited[MAXVEX];void BFS(GraphList plus) { int i; EdgeNode *p; Queue q; for (i = 0; i &lt; plus-&gt;numNodes; i++) { visited[i] = FALSE; } initQueue(&amp;q); for (i = 0; i &lt; plus-&gt;numNodes; i++) { if (!visited[i]) { visited[i] = TRUE; printf(\"%c \", plus-&gt;adjList[i].data); enterQueue(&amp;q, i); while (!emptyQueue(&amp;q)) { deQueue(&amp;q, &amp;i); // 找到当前顶点的边表链表头指针 p = plus-&gt;adjList[i].firstedge; while (p != NULL) { if (!visited[p-&gt;adjvex]) { visited[p-&gt;adjvex] = TRUE; printf(\"%c \", plus-&gt;adjList[p-&gt;adjvex].data); enterQueue(&amp;q, p-&gt;adjvex); } p = p-&gt;next; } } } }} 运行结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"图","slug":"图","permalink":"https://niithub.cn/tags/%E5%9B%BE/"}]},{"title":"阅读过的书籍","date":"2019-05-13T12:27:00.000Z","path":"/posts/42233/","text":"2018年 西南联大行思录 本书是作者浸润于“西南联大”的成果。其间，作者走访海峡两岸的西南联大老校友，亲身接触、交谈，拍摄出电视纪录片数部，积累案头笔记、文献等一手材料不计其数，甚至不乏独家所有。作者寻访西南联大老校友，目的在于寻访“西南联大精神”——在中西合璧下，既有“天下兴亡，匹夫有责”，也有“独立人格，自由精神”的人文精神。本书用文学化的语言进行纪实性的描述，人物访谈时的讲话穿插其中，章法上也化整为零。在一个个小专题内，可见出西南联大人活生生的精神面貌，和对国家、民族的赤诚与担当，更可见出作者对当下文化教育建设的思考与忧虑。从“西南联大”到今天，历史的精神就在“行”与“思”之间跳动，对那激情岁月与美好人格的怀念向往，跃然纸上。 万历十五年 万历十五年，亦即公元1587年，在西欧历史上为西班牙舰队全部出动征英的前一年；而在中国，这平平淡淡的一年中，发生了若干为历史学家所易于忽视的事件。这些事件，表面看来虽似末端小节，但实质上却是以前发生大事的症结，也是将在以后掀起波澜的机缘。在历史学家黄仁宇的眼中，其间的关系因果，恰为历史的重点，而我们的大历史之旅，也自此开始…… 《万历十五年》是黄仁宇的成名之作，也是他的代表作之一。这本书融会了他数十年人生经历与治学体会，首次以“大历史观”分析明代社会之症结，观察现代中国之来路，给人启发良多。英文原本推出后，被美国多所大学采用为教科书，并两次获得美国书卷奖历史类好书的提名。 阿里巴巴Java开发手册 《阿里巴巴Java开发手册》的愿景是码出高效，码出质量。它结合作者的开发经验和架构历程，提炼阿里巴巴集团技术团队的集体编程经验和软件设计智慧，浓缩成为立体的编程规范和最佳实践。众所周知，现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程相关的知识点，其他维度的知识点也会影响软件的最终交付质量，比如，数据库的表结构和索引设计缺陷可能带来软件的架构缺陷或性能风险；单元测试的失位导致集成测试困难；没有鉴权的漏洞代码易被黑客攻击等。所以，本手册以开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、MySQL数据库、工程结构、设计规约七个维度，每个条目下有相应的扩展解释和说明，正例和反例，全面、立体、形象地帮助到开发者的成长和团队代码规约文化的形成。 从严格意义上讲，《阿里巴巴Java开发手册》超越了Java语言本身，明确作为一名合格开发者应该具备的基本素质，因此本手册适合计算机相关行业的管理者和研发人员、高等院校的计算机专业师生、求职者等阅读，希望成为大家如良师益友般的工作手册、工具字典和床头书。 像计算机科学家一样思考Java 《像计算机科学家一样思考Java》作者基于自己在美国各所大学和学院讲授计算机科学导论课程的经验，开创了“像计算机科学家一样思考(Howto Think Like a ComputerScientist)”的教学理念和方法。《像计算机科学家一样思考Java》正是基于这样的方法，用全新的角度、丰富的实例全面地讲解了Java语言。 全书共15章。第1章介绍了编程的基本知识，即什么是编程以及如何编程。第2章到第4章分别介绍了变量和类型、无返回值方法、条件语句和递归等基础知识；第6章到第9章分别介绍了带返回值的方法、迭代、循环、字符串和可变对象；第11章到第15章则分别介绍了对象、数组、面向对象编程等相对高级的话题。全书贯穿了一个GridWorld的程序示例，分三个部分逐步扩展，分别在第5章、第10章和第16章介绍，用以巩固前面相应各章所介绍的知识和概念。附录A介绍了Java图形编程，附录B介绍了Java中的输入输出，附录C和D分别从程序开发和调试的角度给出了有用的建议。 《像计算机科学家一样思考Java》适合Java的初学者和初级程序员阅读，也可以作为相关专业或培训的教程使用。通过学习《像计算机科学家一样思考Java》，读者不仅可以在Java方面达到初窥门径的效果，同时对于如何掌握和应用计算机编程这门技艺也会有一个全面而科学的认识。 重构-改善既有代码的设计 Martin Fowler和《重构:改善既有代码的设计》(中文版)另几位作者清楚揭示了重构过程，他们为面向对象软件开发所做的贡献，难以衡量。《重构:改善既有代码的设计》(中文版)解释重构的原理（principles）和最佳实践方式（best practices），并指出何时何地你应该开始挖掘你的代码以求改善。《重构:改善既有代码的设计》(中文版)的核心是一份完整的重构名录（catalog of refactoring），其中每一项都介绍一种经过实证的代码变换手法（code transformation）的动机和技术。某些项目如Extract Method和Move Field看起来可能很浅显，但不要掉以轻心，因为理解这类技术正是有条不紊地进行重构的关键。 未来世界的幸存者-阮一峰 本书为阮一峰博客文集，主要收录的是作者对技术变革的影响的一些思考，希望能够藉此书让读者意识到世界正在剧烈变化，洪水就在不远处，从而早早准备出路。本书适合所有乐于思考的读者。 微软的梦工场 今年微软亚洲研究院建立十周年，研究院的研究员们纷纷撰文，汇成本书。他们中间，有当年的高考状元，曾经的少年班学子，有“深蓝之父”，有拥有多项专利的 “技术牛人”，有蜚声业界的著名专家，也有尚未出道的年轻学者；通过文化、人才、技术三个角度，揭示微软亚洲研究院独特的文化氛围，记述各自成长的经历，揭密诸多新技术诞生的过程；由微软人说微软自己的故事，生动、直观地介绍号称“世界上最火的实验室”以及被称为“世界上智商最高的人才群体”的真实风貌；同时，通过介绍微软亚洲研究院十年的发展，抽象出一个计算机基础研究机构的成长概貌，特别是总结一个外企研究机构在中国的发展历程，为其他研究机构提供一定的参考意义。 本书汇聚了技术创新、企业文化、人才培养、职业规划、奋斗励志以及东西方文化碰撞等方面诸多鲜活的事例，可以为读者了解最新的计算机技术、外企文化以及个人成才提供一定的借鉴。 黑客与画家 本书是硅谷创业之父Paul Graham 的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。 本书适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。 精彩文段精选 1. 要根据社会需要，改造自己的思想 2. 事实上，财富与金钱是两个概念。金钱只是用来交易财富的一种手段，财富才是有价值的东西 3. 人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里 2019年 1984 《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，有若一个永不褪色的警示标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力益显强大，被誉为20世纪影响最为深远的文学经典之一。 精彩文段精选 1. 你能够创造死人，却不能创造活人。一旦伪造工作被遗忘后，它就会像凯撒大帝一样真实的存在。 2. 过去给抹掉了，而抹掉本身又被遗忘了，谎言便变成了真话。 3. 我懂得方法，我不懂得原因。 黑旗 荣获第100届普利策奖非虚构类作品奖，以约旦国王阿卜杜拉二世的视角看待中东乱局。 软技能-代码之外的生存指南 这是一本真正从“人”（而非技术也非管理）的角度关注软件开发人员自身发展的书。书中论述的内容既涉及生活习惯，又包括思维方式，凸显技术中“人”的因素，全面讲解软件行业从业人员所需知道的所有“软技能”。本书聚焦于软件开发人员生活的方方面面，从揭秘面试的流程到精耕细作出一份杀手级简历，从创建大受欢迎的博客到打造你，从提高自己工作效率到与如何与“拖延症”做斗争，甚至包括如何投资不动产，如何关注自己的健康。本书共分为职业篇、自我营销篇、学习篇、生产力篇、理财篇、健身篇、精神篇等七篇，概括了软件行业从业人员所需的“软技能”。通过阅读本书，软件工程人员、编程人员和其他技术人员能够积极思考自己的职业生涯，丰富自己的生活，让自己更接近成功。 精彩文段精选 1. 尽管我们为自己的智慧感到骄傲，但我们依然是情感动物。我们就像那些穿着西装、打着领带、四处游荡的小孩，假装自己已经长大，其实任何轻微的伤害都能让我们嚎嚎大哭，或者大发雷霆，我们只是已经学会了如何控制和隐藏这些情绪。 2. 从表面上看，身为“专才”后，潜在雇主和客户群都变小了，但是实际上你对他们更具有吸引力了。 3. 许多软件开发人员犯的一个巨大的错误就是，当无法达到标准时，他们不完善自己、迎接挑战，而是降低标准。 4. 很好的创业候选是能够申请专利或受保护的新技术和新方法，而糟糕的创业候选则包括餐厅或其他缺乏独创、很容易被复制的服务。 大学之路：：陪女儿在美国选大学-上册 作者吴军曾在清华大学就读和任教，之后在美国约翰·霍普金斯大学获得博士学位，又因事业有成而成为该校工学院的董事，得以多年来参与美国名牌大学的管理，并且将女儿培养进入麻省理工学院。作者以他和女儿走访过的英美十几所顶级大学为样本，结合他多年来对美国高等教育的系统研究，以及访问这些大学教师和校友的第一手资料，加上自己的深入思考与独到感悟，精心写就《大学之路》。 在书中，作者阐述了英美著名教育家的教育理念，系统地介绍了英美名校的特色和差异，比较了中美两国在教育上的差异，并且结合自己的亲身体会，对年轻人给出了自我发展的建议。作者与美国许多大学有着密切联系，还介绍了美国名牌大学在招生中许多不为人知的细节，并重点解析了其中一些潜规则的历史成因和申请者可能有必要采取的对策。 作为一名事业有成者，作者详细阐述了教育在人生中的重要性，并特别强调人生是一场马拉松，教育乃终身学习，而并非以获得一个名牌大学学位为终结。对大学教育这一严肃话题，作者以一种轻松自在的方式娓娓道来。上册主要介绍了英美大学的教育方法、办学理念和招生特点。下册作者则以半游记的形式，带领读者走访十多所英美名校，既让人如身临其境，又通过一个个实例帮助读者了解各个名校的特点。本书对教育工作者、家长和学生以及留学机构都有一定的借鉴和参考价值。 精彩文段精选 1. 真正的人，就是八个字，第一真实，第二善良，第三健康，第四快乐。\"我觉得我们教育的目标，就是培养和造就拥有现代知识技能和独立思考能力，同时对匡家和社会有所担当的人才。 2. 一所好的大学，应该扮演四个角色。首先它是培养人才的地方，将那些有潜力、有志向的年轻人培养成对未来社会有所贡献的人；第二，它是一个研究的中心，引领世界科技的发展，并且会对一个国家、一个地区产生积极正面的影响；第三，它是一个新思想、新文化的发源地，能推动社会的进步；第四，它是年轻人的家，是他们度过人生好时光的地方。 智能时代 大数据和机器智能的出现，对我们的技术发展、商业和社会都会产生重大的影响。作者吴军在《智能时代：大数据与智能革命重新定义未来》中指出，首先，我们在过去认为非常难以解决的问题，会因为大数据和机器智能的使用而迎刃而解，比如解决癌症个性化治疗的难题。同时，大数据和机器智能还会彻底改变未来的商业模式，很多传统的行业都将采用智能技术实现升级换代，同时改变原有的商业模式。大数据和机器智能对于未来社会的影响是全方位的。 精彩文段精选 1. 数据和信息还是稍有不同，虽然它最大的作用在于承载信息，但是并非所有的数据都承载了有意义的信息。 2. 处理信息和数据可以说是人类所特有的本事，而这个本事的大小和现代智人的社会发展有关。 3. 得到数据和使用数据的能力，是衡量文明发展水平的标准之一。 4. 统计学，有时又被称为数理统计，是建立在概率论基础之上，收集、处理和分析数据，找到数据内在的关联性和规律性的学科。 5. 大数据的第三个重要特征，也是人们常常忽视的，就是它的全面性，或者说完备性。 6. 深蓝的团队其实把一个机器智能的问题变成了一个大数据的问题和大量计算的问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"阅读","slug":"阅读","permalink":"https://niithub.cn/tags/%E9%98%85%E8%AF%BB/"}]}]